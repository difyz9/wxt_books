# æ„å»ºéƒ¨ç½²

## WXT æ‰©å±•æ„å»ºä¼˜åŒ–ä¸éƒ¨ç½²å‘å¸ƒ

æœ¬ç« å°†æ·±å…¥æ¢è®¨ WXT æ‰©å±•çš„æ„å»ºä¼˜åŒ–ç­–ç•¥ã€å‘å¸ƒæµç¨‹å’Œç”Ÿäº§ç¯å¢ƒéƒ¨ç½²çš„æœ€ä½³å®è·µï¼Œç¡®ä¿æ‚¨çš„æ‰©å±•èƒ½å¤Ÿé«˜æ•ˆç¨³å®šåœ°è¿è¡Œã€‚

## æ„å»ºé…ç½®ä¼˜åŒ–

### 1. é«˜çº§æ„å»ºé…ç½®
```typescript
// wxt.config.ts
import { defineConfig } from 'wxt';
import { resolve } from 'path';

export default defineConfig({
  // ç¯å¢ƒé…ç½®
  outDir: 'dist',
  srcDir: 'src',
  publicDir: 'public',
  
  // æ„å»ºä¼˜åŒ–
  vite: (env) => ({
    // åŸºç¡€é…ç½®
    resolve: {
      alias: {
        '@': resolve(__dirname, 'src'),
        '@/components': resolve(__dirname, 'src/components'),
        '@/utils': resolve(__dirname, 'src/utils'),
        '@/types': resolve(__dirname, 'src/types'),
        '@/hooks': resolve(__dirname, 'src/hooks'),
        '@/stores': resolve(__dirname, 'src/stores'),
        '@/assets': resolve(__dirname, 'src/assets')
      }
    },
    
    // å¼€å‘é…ç½®
    ...(env.mode === 'development' && {
      define: {
        __DEV__: true,
        __DEBUG__: true
      },
      esbuild: {
        drop: []
      }
    }),
    
    // ç”Ÿäº§é…ç½®
    ...(env.mode === 'production' && {
      define: {
        __DEV__: false,
        __DEBUG__: false
      },
      esbuild: {
        drop: ['console', 'debugger'],
        legalComments: 'none',
        minifyIdentifiers: true,
        minifySyntax: true,
        minifyWhitespace: true
      },
      build: {
        minify: 'esbuild',
        sourcemap: false,
        rollupOptions: {
          output: {
            manualChunks: {
              vendor: ['react', 'react-dom'],
              ui: ['@headlessui/react', '@heroicons/react'],
              utils: ['lodash', 'date-fns']
            }
          }
        }
      }
    })
  }),
  
  // æ‰©å±•æ¸…å•é…ç½®
  manifest: (env) => ({
    name: env.mode === 'development' ? '[DEV] TabMaster' : 'TabMaster',
    description: 'é«˜æ•ˆçš„æ ‡ç­¾é¡µç®¡ç†å·¥å…·',
    version: process.env.npm_package_version,
    
    // æƒé™é…ç½®
    permissions: [
      'tabs',
      'storage',
      'activeTab',
      'bookmarks',
      'history',
      'notifications'
    ],
    
    // å¯é€‰æƒé™
    optional_permissions: [
      'background',
      'webNavigation',
      'management'
    ],
    
    // ä¸»æœºæƒé™
    host_permissions: env.mode === 'development' 
      ? ['http://localhost:*/*', 'https://localhost:*/*']
      : [],
      
    // å†…å®¹å®‰å…¨ç­–ç•¥
    content_security_policy: {
      extension_pages: "script-src 'self'; object-src 'self';"
    },
    
    // Web å¯è®¿é—®èµ„æº
    web_accessible_resources: [
      {
        resources: ['assets/*', 'content-scripts/*'],
        matches: ['<all_urls>']
      }
    ],
    
    // å¼€å‘ç¯å¢ƒç‰¹å®šé…ç½®
    ...(env.mode === 'development' && {
      content_security_policy: {
        extension_pages: "script-src 'self' 'unsafe-eval'; object-src 'self';"
      }
    })
  }),
  
  // å¤šæµè§ˆå™¨æ”¯æŒ
  browser: process.env.BROWSER || 'chrome',
  
  // è‡ªåŠ¨é‡è½½é…ç½®
  reloadConfig: {
    entries: {
      contentScript: {
        paths: ['src/entrypoints/content/**/*'],
        reloadPage: true
      },
      background: {
        paths: ['src/entrypoints/background/**/*'],
        reloadExtension: true
      },
      popup: {
        paths: ['src/entrypoints/popup/**/*'],
        reloadPage: false
      }
    }
  }
});
```

### 2. ç¯å¢ƒå˜é‡ç®¡ç†
```typescript
// .env.development
VITE_APP_NAME=TabMaster Dev
VITE_API_URL=http://localhost:3000/api
VITE_DEBUG=true
VITE_ANALYTICS_ID=
VITE_ERROR_REPORTING=false

// .env.production
VITE_APP_NAME=TabMaster
VITE_API_URL=https://api.tabmaster.com
VITE_DEBUG=false
VITE_ANALYTICS_ID=UA-XXXXXXXX-X
VITE_ERROR_REPORTING=true

// .env.staging
VITE_APP_NAME=TabMaster Staging
VITE_API_URL=https://staging-api.tabmaster.com
VITE_DEBUG=true
VITE_ANALYTICS_ID=UA-XXXXXXXX-Y
VITE_ERROR_REPORTING=true
```

```typescript
// src/config/env.ts
interface EnvironmentConfig {
  APP_NAME: string;
  API_URL: string;
  DEBUG: boolean;
  ANALYTICS_ID: string;
  ERROR_REPORTING: boolean;
}

const config: EnvironmentConfig = {
  APP_NAME: import.meta.env.VITE_APP_NAME,
  API_URL: import.meta.env.VITE_API_URL,
  DEBUG: import.meta.env.VITE_DEBUG === 'true',
  ANALYTICS_ID: import.meta.env.VITE_ANALYTICS_ID || '',
  ERROR_REPORTING: import.meta.env.VITE_ERROR_REPORTING === 'true'
};

// éªŒè¯å¿…éœ€çš„ç¯å¢ƒå˜é‡
const requiredEnvVars = ['VITE_APP_NAME', 'VITE_API_URL'];
const missingEnvVars = requiredEnvVars.filter(key => !import.meta.env[key]);

if (missingEnvVars.length > 0) {
  throw new Error(`Missing required environment variables: ${missingEnvVars.join(', ')}`);
}

export default config;
```

### 3. ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½
```typescript
// src/entrypoints/popup/App.tsx
import React, { Suspense, lazy } from 'react';
import { ErrorBoundary } from '@/components/ErrorBoundary';
import { LoadingSpinner } from '@/components/LoadingSpinner';

// æ‡’åŠ è½½ç»„ä»¶
const TabManager = lazy(() => import('@/components/TabManager'));
const SettingsPanel = lazy(() => import('@/components/SettingsPanel'));
const AboutPanel = lazy(() => import('@/components/AboutPanel'));

const componentMap = {
  main: TabManager,
  settings: SettingsPanel,
  about: AboutPanel
};

interface AppProps {
  view: keyof typeof componentMap;
}

const App: React.FC<AppProps> = ({ view }) => {
  const Component = componentMap[view];
  
  return (
    <ErrorBoundary>
      <Suspense fallback={<LoadingSpinner />}>
        <Component />
      </Suspense>
    </ErrorBoundary>
  );
};

export default App;
```

```typescript
// src/utils/lazyLoader.ts
interface LazyLoaderOptions {
  timeout?: number;
  retries?: number;
  fallback?: () => Promise<any>;
}

export function createLazyLoader<T>(
  importFn: () => Promise<T>,
  options: LazyLoaderOptions = {}
) {
  const { timeout = 10000, retries = 3, fallback } = options;
  
  return async (): Promise<T> => {
    let lastError: Error;
    
    for (let attempt = 0; attempt < retries; attempt++) {
      try {
        const timeoutPromise = new Promise<never>((_, reject) => {
          setTimeout(() => reject(new Error('Import timeout')), timeout);
        });
        
        return await Promise.race([importFn(), timeoutPromise]);
      } catch (error) {
        lastError = error as Error;
        console.warn(`Import attempt ${attempt + 1} failed:`, error);
        
        // æŒ‡æ•°é€€é¿
        if (attempt < retries - 1) {
          await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
        }
      }
    }
    
    if (fallback) {
      console.warn('Using fallback after all import attempts failed');
      return await fallback();
    }
    
    throw new Error(`Failed to import after ${retries} attempts: ${lastError.message}`);
  };
}

// ä½¿ç”¨ç¤ºä¾‹
export const LazyTabManager = lazy(createLazyLoader(
  () => import('@/components/TabManager'),
  {
    timeout: 5000,
    retries: 2,
    fallback: () => import('@/components/TabManagerFallback')
  }
));
```

## æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. Bundle åˆ†æå’Œä¼˜åŒ–
```bash
# package.json scripts
{
  "scripts": {
    "build": "wxt build",
    "build:analyze": "wxt build --analyze",
    "build:stats": "wxt build --mode production --analyze --json > dist/stats.json",
    "analyze": "npx vite-bundle-analyzer dist/stats.json"
  }
}
```

```typescript
// scripts/analyze-bundle.ts
import fs from 'fs';
import path from 'path';
import { gzipSize } from 'gzip-size';

interface BundleStats {
  file: string;
  size: number;
  gzipSize: number;
  percentage: number;
}

async function analyzeBundles() {
  const distDir = path.resolve('dist');
  const files = fs.readdirSync(distDir, { recursive: true })
    .filter(file => file.toString().endsWith('.js'))
    .map(file => path.join(distDir, file.toString()));
  
  const stats: BundleStats[] = [];
  let totalSize = 0;
  
  for (const file of files) {
    const content = fs.readFileSync(file);
    const size = content.length;
    const gzipSizeBytes = await gzipSize(content);
    
    totalSize += size;
    
    stats.push({
      file: path.relative(distDir, file),
      size,
      gzipSize: gzipSizeBytes,
      percentage: 0 // ç¨åè®¡ç®—
    });
  }
  
  // è®¡ç®—ç™¾åˆ†æ¯”
  stats.forEach(stat => {
    stat.percentage = (stat.size / totalSize) * 100;
  });
  
  // æ’åºå¹¶è¾“å‡º
  stats.sort((a, b) => b.size - a.size);
  
  console.log('\nğŸ“Š Bundle Analysis Report\n');
  console.log('File'.padEnd(40) + 'Size'.padEnd(12) + 'Gzip'.padEnd(12) + 'Percentage');
  console.log('-'.repeat(80));
  
  stats.forEach(stat => {
    console.log(
      stat.file.padEnd(40) +
      formatBytes(stat.size).padEnd(12) +
      formatBytes(stat.gzipSize).padEnd(12) +
      `${stat.percentage.toFixed(1)}%`
    );
  });
  
  console.log('-'.repeat(80));
  console.log(`Total: ${formatBytes(totalSize)}`);
  
  // æ£€æŸ¥å¤§æ–‡ä»¶
  const largeFiles = stats.filter(stat => stat.size > 100 * 1024); // 100KB
  if (largeFiles.length > 0) {
    console.log('\nâš ï¸  Large files detected (>100KB):');
    largeFiles.forEach(file => {
      console.log(`  ${file.file}: ${formatBytes(file.size)}`);
    });
  }
}

function formatBytes(bytes: number): string {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}

analyzeBundles().catch(console.error);
```

### 2. èµ„æºä¼˜åŒ–
```typescript
// src/utils/assetOptimizer.ts
class AssetOptimizer {
  private cache = new Map<string, string>();
  
  // å›¾ç‰‡æ‡’åŠ è½½
  static createImageLoader(src: string, options: {
    placeholder?: string;
    quality?: number;
    format?: 'webp' | 'avif' | 'auto';
  } = {}) {
    return new Promise<HTMLImageElement>((resolve, reject) => {
      const img = new Image();
      
      img.onload = () => resolve(img);
      img.onerror = reject;
      
      // æ·»åŠ è´¨é‡å’Œæ ¼å¼ä¼˜åŒ–
      let optimizedSrc = src;
      if (options.quality && options.quality < 100) {
        optimizedSrc += `?quality=${options.quality}`;
      }
      
      img.src = optimizedSrc;
    });
  }
  
  // CSS èµ„æºå†…è”
  static async inlineCSS(cssPath: string): Promise<string> {
    try {
      const response = await fetch(chrome.runtime.getURL(cssPath));
      return await response.text();
    } catch (error) {
      console.error('Failed to inline CSS:', error);
      return '';
    }
  }
  
  // å­—ä½“é¢„åŠ è½½
  static preloadFont(fontPath: string, format = 'woff2') {
    const link = document.createElement('link');
    link.rel = 'preload';
    link.as = 'font';
    link.type = `font/${format}`;
    link.href = chrome.runtime.getURL(fontPath);
    link.crossOrigin = 'anonymous';
    
    document.head.appendChild(link);
  }
  
  // èµ„æºé¢„ç¼“å­˜
  async precacheResources(resources: string[]) {
    const promises = resources.map(async (resource) => {
      if (this.cache.has(resource)) {
        return this.cache.get(resource);
      }
      
      try {
        const response = await fetch(chrome.runtime.getURL(resource));
        const content = await response.text();
        this.cache.set(resource, content);
        return content;
      } catch (error) {
        console.error(`Failed to cache resource: ${resource}`, error);
        return null;
      }
    });
    
    return Promise.all(promises);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const optimizer = new AssetOptimizer();

// é¢„ç¼“å­˜å…³é”®èµ„æº
optimizer.precacheResources([
  'assets/icons/icon-16.png',
  'assets/icons/icon-32.png',
  'assets/styles/critical.css'
]);

// é¢„åŠ è½½å­—ä½“
AssetOptimizer.preloadFont('assets/fonts/Inter-Regular.woff2');
```

### 3. å†…å­˜ç®¡ç†
```typescript
// src/utils/memoryManager.ts
class MemoryManager {
  private static instance: MemoryManager;
  private intervals = new Set<number>();
  private listeners = new Set<() => void>();
  private observers = new Set<MutationObserver | IntersectionObserver>();
  
  static getInstance(): MemoryManager {
    if (!MemoryManager.instance) {
      MemoryManager.instance = new MemoryManager();
    }
    return MemoryManager.instance;
  }
  
  // æ³¨å†Œå®šæ—¶å™¨
  registerInterval(callback: () => void, delay: number): number {
    const id = window.setInterval(callback, delay);
    this.intervals.add(id);
    return id;
  }
  
  // æ³¨å†Œäº‹ä»¶ç›‘å¬å™¨
  registerEventListener(
    target: EventTarget,
    event: string,
    handler: EventListener,
    options?: AddEventListenerOptions
  ): () => void {
    target.addEventListener(event, handler, options);
    
    const cleanup = () => {
      target.removeEventListener(event, handler, options);
      this.listeners.delete(cleanup);
    };
    
    this.listeners.add(cleanup);
    return cleanup;
  }
  
  // æ³¨å†Œè§‚å¯Ÿå™¨
  registerObserver(observer: MutationObserver | IntersectionObserver): void {
    this.observers.add(observer);
  }
  
  // æ¸…ç†æ‰€æœ‰èµ„æº
  cleanup(): void {
    // æ¸…ç†å®šæ—¶å™¨
    this.intervals.forEach(id => clearInterval(id));
    this.intervals.clear();
    
    // æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
    this.listeners.forEach(cleanup => cleanup());
    this.listeners.clear();
    
    // æ¸…ç†è§‚å¯Ÿå™¨
    this.observers.forEach(observer => observer.disconnect());
    this.observers.clear();
    
    console.log('Memory cleanup completed');
  }
  
  // å†…å­˜ä½¿ç”¨ç›‘æ§
  monitorMemoryUsage(threshold = 50 * 1024 * 1024): void { // 50MB
    const checkMemory = () => {
      if ('memory' in performance) {
        const memory = (performance as any).memory;
        const used = memory.usedJSHeapSize;
        
        if (used > threshold) {
          console.warn(`High memory usage detected: ${this.formatBytes(used)}`);
          this.suggestCleanup();
        }
      }
    };
    
    this.registerInterval(checkMemory, 30000); // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
  }
  
  private suggestCleanup(): void {
    // æ¸…ç†å¤§å¯¹è±¡ç¼“å­˜
    if (window.caches) {
      caches.keys().then(keys => {
        keys.forEach(key => {
          if (key.includes('large-data')) {
            caches.delete(key);
          }
        });
      });
    }
    
    // è§¦å‘åƒåœ¾å›æ”¶å»ºè®®
    if (window.gc) {
      window.gc();
    }
  }
  
  private formatBytes(bytes: number): string {
    const sizes = ['B', 'KB', 'MB', 'GB'];
    if (bytes === 0) return '0 B';
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
  }
}

// å…¨å±€æ¸…ç†é’©å­
export function useMemoryCleanup() {
  const manager = MemoryManager.getInstance();
  
  useEffect(() => {
    return () => {
      manager.cleanup();
    };
  }, []);
  
  return manager;
}
```

## å¤šæµè§ˆå™¨å…¼å®¹æ€§

### 1. æµè§ˆå™¨é€‚é…é…ç½®
```typescript
// scripts/build-multi-browser.ts
import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

const browsers = ['chrome', 'firefox', 'edge', 'safari'];

interface BrowserConfig {
  manifest: Record<string, any>;
  features: string[];
  polyfills: string[];
}

const browserConfigs: Record<string, BrowserConfig> = {
  chrome: {
    manifest: {
      manifest_version: 3,
      background: {
        service_worker: 'background.js',
        type: 'module'
      }
    },
    features: ['chrome.action', 'chrome.storage.session'],
    polyfills: []
  },
  
  firefox: {
    manifest: {
      manifest_version: 2,
      background: {
        scripts: ['background.js'],
        persistent: false
      },
      browser_action: {}, // æ›¿ä»£ action
      browser_specific_settings: {
        gecko: {
          id: 'tabmaster@example.com',
          strict_min_version: '109.0'
        }
      }
    },
    features: ['browser.browserAction', 'browser.storage.local'],
    polyfills: ['webextension-polyfill']
  },
  
  edge: {
    manifest: {
      manifest_version: 3,
      background: {
        service_worker: 'background.js',
        type: 'module'
      }
    },
    features: ['chrome.action', 'chrome.storage.session'],
    polyfills: []
  },
  
  safari: {
    manifest: {
      manifest_version: 2,
      background: {
        scripts: ['background.js'],
        persistent: false
      }
    },
    features: ['browser.browserAction'],
    polyfills: ['webextension-polyfill']
  }
};

async function buildForBrowser(browser: string) {
  console.log(`Building for ${browser}...`);
  
  const config = browserConfigs[browser];
  const outputDir = path.resolve(`dist-${browser}`);
  
  // è®¾ç½®ç¯å¢ƒå˜é‡
  process.env.BROWSER = browser;
  process.env.TARGET_BROWSER = browser;
  
  // æ„å»º
  execSync(`wxt build --browser ${browser} --outDir ${outputDir}`, {
    stdio: 'inherit'
  });
  
  // åå¤„ç†
  await postProcessBuild(browser, outputDir, config);
  
  console.log(`âœ… ${browser} build completed`);
}

async function postProcessBuild(
  browser: string,
  outputDir: string,
  config: BrowserConfig
) {
  // ä¿®æ”¹ manifest.json
  const manifestPath = path.join(outputDir, 'manifest.json');
  const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
  
  // åº”ç”¨æµè§ˆå™¨ç‰¹å®šé…ç½®
  Object.assign(manifest, config.manifest);
  
  // Firefox ç‰¹æ®Šå¤„ç†
  if (browser === 'firefox') {
    // ç§»é™¤ä¸æ”¯æŒçš„å­—æ®µ
    delete manifest.action;
    delete manifest.background?.service_worker;
    
    // æ·»åŠ  browser_action
    if (manifest.action) {
      manifest.browser_action = manifest.action;
      delete manifest.action;
    }
  }
  
  fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 2));
  
  // æ·»åŠ  polyfill
  if (config.polyfills.includes('webextension-polyfill')) {
    await addWebExtensionPolyfill(outputDir);
  }
}

async function addWebExtensionPolyfill(outputDir: string) {
  const polyfillPath = require.resolve('webextension-polyfill/dist/browser-polyfill.js');
  const polyfillContent = fs.readFileSync(polyfillPath, 'utf8');
  
  // æ·»åŠ  polyfill åˆ°æ‰€æœ‰ JS æ–‡ä»¶çš„å¼€å¤´
  const jsFiles = fs.readdirSync(outputDir)
    .filter(file => file.endsWith('.js'))
    .map(file => path.join(outputDir, file));
  
  jsFiles.forEach(filePath => {
    const content = fs.readFileSync(filePath, 'utf8');
    const withPolyfill = `${polyfillContent}\n\n${content}`;
    fs.writeFileSync(filePath, withPolyfill);
  });
}

// æ„å»ºæ‰€æœ‰æµè§ˆå™¨ç‰ˆæœ¬
async function buildAll() {
  for (const browser of browsers) {
    try {
      await buildForBrowser(browser);
    } catch (error) {
      console.error(`âŒ Failed to build for ${browser}:`, error);
    }
  }
  
  console.log('ğŸ‰ All builds completed');
}

buildAll().catch(console.error);
```

### 2. API å…¼å®¹æ€§å¤„ç†
```typescript
// src/utils/browserAPI.ts
interface BrowserAPI {
  tabs: typeof chrome.tabs;
  storage: typeof chrome.storage;
  runtime: typeof chrome.runtime;
  action?: typeof chrome.action;
  browserAction?: any;
}

class BrowserAPIAdapter {
  private api: BrowserAPI;
  
  constructor() {
    // æ£€æµ‹æµè§ˆå™¨ç¯å¢ƒ
    if (typeof browser !== 'undefined') {
      // Firefox, Safari with polyfill
      this.api = browser as any;
    } else if (typeof chrome !== 'undefined') {
      // Chrome, Edge
      this.api = chrome as any;
    } else {
      throw new Error('Unsupported browser environment');
    }
  }
  
  // ç»Ÿä¸€çš„ Action API
  get action() {
    if (this.api.action) {
      return this.api.action;
    } else if (this.api.browserAction) {
      // Firefox å…¼å®¹æ€§åŒ…è£…
      return {
        setBadgeText: this.api.browserAction.setBadgeText.bind(this.api.browserAction),
        setBadgeBackgroundColor: this.api.browserAction.setBadgeBackgroundColor.bind(this.api.browserAction),
        setTitle: this.api.browserAction.setTitle.bind(this.api.browserAction),
        setIcon: this.api.browserAction.setIcon.bind(this.api.browserAction),
        setPopup: this.api.browserAction.setPopup.bind(this.api.browserAction),
        onClicked: this.api.browserAction.onClicked
      };
    }
    throw new Error('Action API not available');
  }
  
  // ç»Ÿä¸€çš„å­˜å‚¨ API
  get storage() {
    return {
      local: {
        get: this.promisify(this.api.storage.local.get),
        set: this.promisify(this.api.storage.local.set),
        remove: this.promisify(this.api.storage.local.remove),
        clear: this.promisify(this.api.storage.local.clear)
      },
      sync: {
        get: this.promisify(this.api.storage.sync.get),
        set: this.promisify(this.api.storage.sync.set),
        remove: this.promisify(this.api.storage.sync.remove),
        clear: this.promisify(this.api.storage.sync.clear)
      }
    };
  }
  
  // ç»Ÿä¸€çš„æ ‡ç­¾é¡µ API
  get tabs() {
    return {
      query: this.promisify(this.api.tabs.query),
      get: this.promisify(this.api.tabs.get),
      create: this.promisify(this.api.tabs.create),
      update: this.promisify(this.api.tabs.update),
      remove: this.promisify(this.api.tabs.remove),
      reload: this.promisify(this.api.tabs.reload),
      onActivated: this.api.tabs.onActivated,
      onUpdated: this.api.tabs.onUpdated,
      onRemoved: this.api.tabs.onRemoved
    };
  }
  
  // ç»Ÿä¸€çš„è¿è¡Œæ—¶ API
  get runtime() {
    return {
      sendMessage: this.promisify(this.api.runtime.sendMessage),
      onMessage: this.api.runtime.onMessage,
      getURL: this.api.runtime.getURL,
      onInstalled: this.api.runtime.onInstalled,
      onStartup: this.api.runtime.onStartup,
      getManifest: this.api.runtime.getManifest
    };
  }
  
  // Promise åŒ…è£…å™¨
  private promisify<T extends any[], R>(
    fn: (...args: [...T, (result: R) => void]) => void
  ) {
    return (...args: T): Promise<R> => {
      return new Promise((resolve, reject) => {
        fn(...args, (result: R) => {
          if (this.api.runtime.lastError) {
            reject(new Error(this.api.runtime.lastError.message));
          } else {
            resolve(result);
          }
        });
      });
    };
  }
  
  // æµè§ˆå™¨æ£€æµ‹
  getBrowserInfo() {
    const userAgent = navigator.userAgent;
    
    if (userAgent.includes('Edg/')) {
      return { name: 'edge', version: this.extractVersion(userAgent, 'Edg/') };
    } else if (userAgent.includes('Firefox/')) {
      return { name: 'firefox', version: this.extractVersion(userAgent, 'Firefox/') };
    } else if (userAgent.includes('Safari/') && !userAgent.includes('Chrome/')) {
      return { name: 'safari', version: this.extractVersion(userAgent, 'Version/') };
    } else if (userAgent.includes('Chrome/')) {
      return { name: 'chrome', version: this.extractVersion(userAgent, 'Chrome/') };
    }
    
    return { name: 'unknown', version: '0' };
  }
  
  private extractVersion(userAgent: string, prefix: string): string {
    const index = userAgent.indexOf(prefix);
    if (index === -1) return '0';
    
    const versionStart = index + prefix.length;
    const versionEnd = userAgent.indexOf(' ', versionStart);
    return userAgent.substring(versionStart, versionEnd === -1 ? undefined : versionEnd);
  }
}

export const browserAPI = new BrowserAPIAdapter();
export default browserAPI;
```

## å‘å¸ƒæµç¨‹è‡ªåŠ¨åŒ–

### 1. ç‰ˆæœ¬ç®¡ç†
```typescript
// scripts/version-bump.ts
import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';

type VersionType = 'patch' | 'minor' | 'major';

interface VersionConfig {
  files: string[];
  gitTag: boolean;
  changelog: boolean;
  npm: boolean;
}

const config: VersionConfig = {
  files: [
    'package.json',
    'src/manifest.json',
    'wxt.config.ts'
  ],
  gitTag: true,
  changelog: true,
  npm: false
};

function getCurrentVersion(): string {
  const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
  return packageJson.version;
}

function bumpVersion(current: string, type: VersionType): string {
  const [major, minor, patch] = current.split('.').map(Number);
  
  switch (type) {
    case 'major':
      return `${major + 1}.0.0`;
    case 'minor':
      return `${major}.${minor + 1}.0`;
    case 'patch':
      return `${major}.${minor}.${patch + 1}`;
    default:
      throw new Error(`Invalid version type: ${type}`);
  }
}

function updateVersionInFiles(newVersion: string): void {
  config.files.forEach(filePath => {
    if (!fs.existsSync(filePath)) {
      console.warn(`File not found: ${filePath}`);
      return;
    }
    
    const content = fs.readFileSync(filePath, 'utf8');
    let updatedContent: string;
    
    if (filePath.endsWith('.json')) {
      const json = JSON.parse(content);
      json.version = newVersion;
      updatedContent = JSON.stringify(json, null, 2);
    } else if (filePath.endsWith('.ts')) {
      updatedContent = content.replace(
        /version:\s*['"`][^'"`]*['"`]/g,
        `version: '${newVersion}'`
      );
    } else {
      updatedContent = content.replace(
        /version[=:]\s*['"`][^'"`]*['"`]/g,
        `version: '${newVersion}'`
      );
    }
    
    fs.writeFileSync(filePath, updatedContent);
    console.log(`âœ… Updated version in ${filePath}`);
  });
}

function generateChangelog(version: string): void {
  if (!config.changelog) return;
  
  const date = new Date().toISOString().split('T')[0];
  const changelogPath = 'CHANGELOG.md';
  
  // è·å–æœ€æ–°çš„ git æäº¤
  const commits = execSync('git log --oneline --since="1 week ago"', { encoding: 'utf8' })
    .trim()
    .split('\n')
    .filter(commit => commit.length > 0);
  
  const changelogEntry = `
## [${version}] - ${date}

### Added
- æ–°åŠŸèƒ½å¾…è¡¥å……

### Changed
- æ”¹è¿›å†…å®¹å¾…è¡¥å……

### Fixed
- ä¿®å¤å†…å®¹å¾…è¡¥å……

### Recent Commits
${commits.map(commit => `- ${commit}`).join('\n')}

`;
  
  if (fs.existsSync(changelogPath)) {
    const existingChangelog = fs.readFileSync(changelogPath, 'utf8');
    const updatedChangelog = existingChangelog.replace(
      /^# Changelog\n/,
      `# Changelog\n${changelogEntry}`
    );
    fs.writeFileSync(changelogPath, updatedChangelog);
  } else {
    fs.writeFileSync(changelogPath, `# Changelog\n${changelogEntry}`);
  }
  
  console.log(`âœ… Updated changelog`);
}

function createGitTag(version: string): void {
  if (!config.gitTag) return;
  
  try {
    execSync('git add .');
    execSync(`git commit -m "chore: bump version to ${version}"`);
    execSync(`git tag -a v${version} -m "Release version ${version}"`);
    console.log(`âœ… Created git tag v${version}`);
  } catch (error) {
    console.error('Failed to create git tag:', error);
  }
}

async function main() {
  const args = process.argv.slice(2);
  const versionType = (args[0] as VersionType) || 'patch';
  
  if (!['patch', 'minor', 'major'].includes(versionType)) {
    console.error('Usage: npm run version [patch|minor|major]');
    process.exit(1);
  }
  
  const currentVersion = getCurrentVersion();
  const newVersion = bumpVersion(currentVersion, versionType);
  
  console.log(`Bumping version from ${currentVersion} to ${newVersion}`);
  
  // æ›´æ–°ç‰ˆæœ¬å·
  updateVersionInFiles(newVersion);
  
  // ç”Ÿæˆæ›´æ–°æ—¥å¿—
  generateChangelog(newVersion);
  
  // åˆ›å»º Git æ ‡ç­¾
  createGitTag(newVersion);
  
  console.log(`ğŸ‰ Version bumped successfully to ${newVersion}`);
}

main().catch(console.error);
```

### 2. è‡ªåŠ¨åŒ–æ„å»ºå’Œå‘å¸ƒ
```yaml
# .github/workflows/release.yml
name: Release Extension

on:
  push:
    tags:
      - 'v*'

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        browser: [chrome, firefox, edge]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run tests
        run: npm test
        
      - name: Build extension
        run: npm run build:${{ matrix.browser }}
        env:
          NODE_ENV: production
          
      - name: Package extension
        run: |
          cd dist-${{ matrix.browser }}
          zip -r ../extension-${{ matrix.browser }}-${{ github.ref_name }}.zip .
          
      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: extension-${{ matrix.browser }}
          path: extension-${{ matrix.browser }}-${{ github.ref_name }}.zip
          
      - name: Create Release
        if: matrix.browser == 'chrome'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref_name }}
          release_name: Release ${{ github.ref_name }}
          draft: false
          prerelease: false
          body: |
            ## ğŸš€ Release Notes
            
            ### New Features
            - Add your new features here
            
            ### Improvements
            - Add your improvements here
            
            ### Bug Fixes
            - Add your bug fixes here
            
            ### Browser Support
            - âœ… Chrome
            - âœ… Firefox
            - âœ… Edge
            
            ## ğŸ“¦ Downloads
            - [Chrome Extension](./extension-chrome-${{ github.ref_name }}.zip)
            - [Firefox Extension](./extension-firefox-${{ github.ref_name }}.zip)
            - [Edge Extension](./extension-edge-${{ github.ref_name }}.zip)

  deploy-chrome-store:
    needs: build-and-release
    runs-on: ubuntu-latest
    if: github.ref_type == 'tag'
    
    steps:
      - name: Download Chrome artifact
        uses: actions/download-artifact@v3
        with:
          name: extension-chrome
          
      - name: Upload to Chrome Web Store
        uses: mnao305/chrome-extension-upload@v4.0.1
        with:
          file-path: extension-chrome-${{ github.ref_name }}.zip
          extension-id: ${{ secrets.CHROME_EXTENSION_ID }}
          client-id: ${{ secrets.CHROME_CLIENT_ID }}
          client-secret: ${{ secrets.CHROME_CLIENT_SECRET }}
          refresh-token: ${{ secrets.CHROME_REFRESH_TOKEN }}
          
  deploy-firefox-store:
    needs: build-and-release
    runs-on: ubuntu-latest
    if: github.ref_type == 'tag'
    
    steps:
      - name: Download Firefox artifact
        uses: actions/download-artifact@v3
        with:
          name: extension-firefox
          
      - name: Upload to Firefox Add-ons
        uses: trmcnvn/firefox-addon@v1
        with:
          uuid: ${{ secrets.FIREFOX_EXTENSION_UUID }}
          xpi: extension-firefox-${{ github.ref_name }}.zip
          manifest: dist-firefox/manifest.json
          api-key: ${{ secrets.FIREFOX_API_KEY }}
          api-secret: ${{ secrets.FIREFOX_API_SECRET }}
```

### 3. å‘å¸ƒè„šæœ¬
```bash
#!/bin/bash
# scripts/release.sh

set -e

# é¢œè‰²å®šä¹‰
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# å‡½æ•°å®šä¹‰
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# æ£€æŸ¥å¿…è¦æ¡ä»¶
check_prerequisites() {
    log_info "Checking prerequisites..."
    
    # æ£€æŸ¥ Git çŠ¶æ€
    if [[ -n $(git status --porcelain) ]]; then
        log_error "Working directory is not clean. Please commit or stash changes."
        exit 1
    fi
    
    # æ£€æŸ¥åˆ†æ”¯
    current_branch=$(git branch --show-current)
    if [[ "$current_branch" != "main" && "$current_branch" != "master" ]]; then
        log_warn "Not on main/master branch. Current branch: $current_branch"
        read -p "Continue? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 1
        fi
    fi
    
    # æ£€æŸ¥ npm ä¾èµ–
    if [[ ! -d "node_modules" ]]; then
        log_info "Installing dependencies..."
        npm ci
    fi
    
    log_info "Prerequisites check passed"
}

# è¿è¡Œæµ‹è¯•
run_tests() {
    log_info "Running tests..."
    
    if ! npm test; then
        log_error "Tests failed. Aborting release."
        exit 1
    fi
    
    log_info "All tests passed"
}

# æ„å»ºæ‰€æœ‰æµè§ˆå™¨ç‰ˆæœ¬
build_all() {
    log_info "Building for all browsers..."
    
    local browsers=("chrome" "firefox" "edge")
    
    for browser in "${browsers[@]}"; do
        log_info "Building for $browser..."
        
        if ! npm run build:$browser; then
            log_error "Build failed for $browser"
            exit 1
        fi
        
        # åˆ›å»ºå‹ç¼©åŒ…
        local version=$(node -p "require('./package.json').version")
        local zip_name="extension-$browser-v$version.zip"
        
        cd "dist-$browser"
        zip -r "../$zip_name" .
        cd ..
        
        log_info "Created $zip_name"
    done
    
    log_info "All builds completed"
}

# ä¸Šä¼ åˆ°åº”ç”¨å•†åº—
upload_to_stores() {
    log_info "Uploading to browser stores..."
    
    # Chrome Web Store
    if [[ -n "$CHROME_EXTENSION_ID" ]]; then
        log_info "Uploading to Chrome Web Store..."
        # è¿™é‡Œå®ç° Chrome Web Store ä¸Šä¼ é€»è¾‘
    else
        log_warn "Chrome extension ID not set, skipping Chrome Web Store upload"
    fi
    
    # Firefox Add-ons
    if [[ -n "$FIREFOX_EXTENSION_UUID" ]]; then
        log_info "Uploading to Firefox Add-ons..."
        # è¿™é‡Œå®ç° Firefox Add-ons ä¸Šä¼ é€»è¾‘
    else
        log_warn "Firefox extension UUID not set, skipping Firefox Add-ons upload"
    fi
    
    log_info "Store uploads completed"
}

# ä¸»å‡½æ•°
main() {
    local version_type=${1:-patch}
    
    log_info "Starting release process with version type: $version_type"
    
    # æ£€æŸ¥å‰ç½®æ¡ä»¶
    check_prerequisites
    
    # è¿è¡Œæµ‹è¯•
    run_tests
    
    # ç‰ˆæœ¬å‡çº§
    log_info "Bumping version..."
    npm run version:$version_type
    
    # æ„å»º
    build_all
    
    # æ¨é€åˆ° Git
    log_info "Pushing to Git..."
    git push origin main --tags
    
    # ä¸Šä¼ åˆ°åº”ç”¨å•†åº—ï¼ˆå¦‚æœé…ç½®äº†ï¼‰
    if [[ "$2" == "--upload" ]]; then
        upload_to_stores
    fi
    
    log_info "ğŸ‰ Release process completed successfully!"
}

# è„šæœ¬å…¥å£
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
```

## éƒ¨ç½²ç›‘æ§å’Œç»´æŠ¤

### 1. é”™è¯¯ç›‘æ§
```typescript
// src/utils/errorReporting.ts
interface ErrorReport {
  message: string;
  stack?: string;
  url: string;
  lineNumber?: number;
  columnNumber?: number;
  userAgent: string;
  version: string;
  timestamp: number;
  userId?: string;
  context?: Record<string, any>;
}

class ErrorReporter {
  private queue: ErrorReport[] = [];
  private isOnline = navigator.onLine;
  private maxQueueSize = 50;
  private reportingUrl: string;
  
  constructor(reportingUrl: string) {
    this.reportingUrl = reportingUrl;
    this.setupEventListeners();
    this.startBatchReporting();
  }
  
  private setupEventListeners() {
    // å…¨å±€é”™è¯¯æ•è·
    window.addEventListener('error', (event) => {
      this.reportError({
        message: event.message,
        stack: event.error?.stack,
        url: event.filename,
        lineNumber: event.lineno,
        columnNumber: event.colno,
        userAgent: navigator.userAgent,
        version: chrome.runtime.getManifest().version,
        timestamp: Date.now()
      });
    });
    
    // Promise æ‹’ç»æ•è·
    window.addEventListener('unhandledrejection', (event) => {
      this.reportError({
        message: `Unhandled Promise Rejection: ${event.reason}`,
        stack: event.reason?.stack,
        url: window.location.href,
        userAgent: navigator.userAgent,
        version: chrome.runtime.getManifest().version,
        timestamp: Date.now()
      });
    });
    
    // ç½‘ç»œçŠ¶æ€ç›‘å¬
    window.addEventListener('online', () => {
      this.isOnline = true;
      this.flushQueue();
    });
    
    window.addEventListener('offline', () => {
      this.isOnline = false;
    });
  }
  
  reportError(error: Partial<ErrorReport>) {
    const report: ErrorReport = {
      message: error.message || 'Unknown error',
      stack: error.stack,
      url: error.url || window.location.href,
      lineNumber: error.lineNumber,
      columnNumber: error.columnNumber,
      userAgent: navigator.userAgent,
      version: chrome.runtime.getManifest().version,
      timestamp: Date.now(),
      ...error
    };
    
    this.queue.push(report);
    
    // é™åˆ¶é˜Ÿåˆ—å¤§å°
    if (this.queue.length > this.maxQueueSize) {
      this.queue = this.queue.slice(-this.maxQueueSize);
    }
    
    // ç«‹å³å‘é€ä¸¥é‡é”™è¯¯
    if (this.isCriticalError(report)) {
      this.sendReports([report]);
    }
  }
  
  private isCriticalError(report: ErrorReport): boolean {
    const criticalPatterns = [
      /manifest/i,
      /permission/i,
      /chrome\./i,
      /extension/i
    ];
    
    return criticalPatterns.some(pattern => 
      pattern.test(report.message) || 
      pattern.test(report.stack || '')
    );
  }
  
  private startBatchReporting() {
    setInterval(() => {
      if (this.queue.length > 0 && this.isOnline) {
        this.flushQueue();
      }
    }, 30000); // æ¯30ç§’å‘é€ä¸€æ¬¡
  }
  
  private async flushQueue() {
    if (this.queue.length === 0 || !this.isOnline) return;
    
    const reports = [...this.queue];
    this.queue = [];
    
    await this.sendReports(reports);
  }
  
  private async sendReports(reports: ErrorReport[]) {
    try {
      const response = await fetch(this.reportingUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ errors: reports })
      });
      
      if (!response.ok) {
        // å‘é€å¤±è´¥ï¼Œé‡æ–°åŠ å…¥é˜Ÿåˆ—
        this.queue.unshift(...reports);
      }
    } catch (error) {
      console.error('Failed to send error reports:', error);
      // å‘é€å¤±è´¥ï¼Œé‡æ–°åŠ å…¥é˜Ÿåˆ—
      this.queue.unshift(...reports);
    }
  }
}

// åˆå§‹åŒ–é”™è¯¯æŠ¥å‘Š
if (import.meta.env.VITE_ERROR_REPORTING === 'true') {
  const reporter = new ErrorReporter(import.meta.env.VITE_ERROR_REPORTING_URL);
  
  // å¯¼å‡ºå…¨å±€å‡½æ•°
  window.__reportError = (error: any, context?: Record<string, any>) => {
    reporter.reportError({
      message: error.message || String(error),
      stack: error.stack,
      context
    });
  };
}
```

### 2. æ€§èƒ½ç›‘æ§
```typescript
// src/utils/performanceMonitor.ts
interface PerformanceMetric {
  name: string;
  value: number;
  timestamp: number;
  context?: Record<string, any>;
}

class PerformanceMonitor {
  private metrics: PerformanceMetric[] = [];
  private observers: PerformanceObserver[] = [];
  
  constructor() {
    this.setupObservers();
    this.trackVitals();
  }
  
  private setupObservers() {
    // è§‚å¯Ÿé•¿ä»»åŠ¡
    if ('PerformanceObserver' in window) {
      const longTaskObserver = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          this.recordMetric('long-task', entry.duration, {
            startTime: entry.startTime,
            name: entry.name
          });
        }
      });
      
      try {
        longTaskObserver.observe({ entryTypes: ['longtask'] });
        this.observers.push(longTaskObserver);
      } catch (e) {
        console.warn('Long task observer not supported');
      }
    }
    
    // è§‚å¯Ÿèµ„æºåŠ è½½
    const resourceObserver = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.entryType === 'resource') {
          const resourceEntry = entry as PerformanceResourceTiming;
          this.recordMetric('resource-load', resourceEntry.duration, {
            name: resourceEntry.name,
            size: resourceEntry.transferSize,
            type: resourceEntry.initiatorType
          });
        }
      }
    });
    
    try {
      resourceObserver.observe({ entryTypes: ['resource'] });
      this.observers.push(resourceObserver);
    } catch (e) {
      console.warn('Resource observer not supported');
    }
  }
  
  private trackVitals() {
    // é¦–æ¬¡å†…å®¹ç»˜åˆ¶ (FCP)
    const fcpObserver = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.name === 'first-contentful-paint') {
          this.recordMetric('fcp', entry.startTime);
        }
      }
    });
    
    try {
      fcpObserver.observe({ entryTypes: ['paint'] });
      this.observers.push(fcpObserver);
    } catch (e) {
      console.warn('Paint observer not supported');
    }
    
    // ç´¯ç§¯å¸ƒå±€åç§» (CLS)
    let clsValue = 0;
    const clsObserver = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (!(entry as any).hadRecentInput) {
          clsValue += (entry as any).value;
        }
      }
    });
    
    try {
      clsObserver.observe({ entryTypes: ['layout-shift'] });
      this.observers.push(clsObserver);
      
      // å®šæœŸè®°å½• CLS
      setInterval(() => {
        if (clsValue > 0) {
          this.recordMetric('cls', clsValue);
          clsValue = 0;
        }
      }, 5000);
    } catch (e) {
      console.warn('Layout shift observer not supported');
    }
  }
  
  recordMetric(name: string, value: number, context?: Record<string, any>) {
    this.metrics.push({
      name,
      value,
      timestamp: Date.now(),
      context
    });
    
    // é™åˆ¶æŒ‡æ ‡æ•°é‡
    if (this.metrics.length > 1000) {
      this.metrics = this.metrics.slice(-500);
    }
  }
  
  // æµ‹é‡å‡½æ•°æ‰§è¡Œæ—¶é—´
  measureFunction<T>(name: string, fn: () => T): T {
    const start = performance.now();
    const result = fn();
    const end = performance.now();
    
    this.recordMetric(`function-${name}`, end - start);
    return result;
  }
  
  // æµ‹é‡å¼‚æ­¥å‡½æ•°æ‰§è¡Œæ—¶é—´
  async measureAsyncFunction<T>(name: string, fn: () => Promise<T>): Promise<T> {
    const start = performance.now();
    const result = await fn();
    const end = performance.now();
    
    this.recordMetric(`async-function-${name}`, end - start);
    return result;
  }
  
  // è·å–æ€§èƒ½æŠ¥å‘Š
  getPerformanceReport() {
    const now = Date.now();
    const last5Minutes = now - 5 * 60 * 1000;
    
    const recentMetrics = this.metrics.filter(m => m.timestamp > last5Minutes);
    
    const report = {
      timestamp: now,
      totalMetrics: this.metrics.length,
      recentMetrics: recentMetrics.length,
      summary: this.generateSummary(recentMetrics),
      alerts: this.generateAlerts(recentMetrics)
    };
    
    return report;
  }
  
  private generateSummary(metrics: PerformanceMetric[]) {
    const summary: Record<string, { count: number; avg: number; max: number }> = {};
    
    metrics.forEach(metric => {
      if (!summary[metric.name]) {
        summary[metric.name] = { count: 0, avg: 0, max: 0 };
      }
      
      const s = summary[metric.name];
      s.count++;
      s.max = Math.max(s.max, metric.value);
      s.avg = (s.avg * (s.count - 1) + metric.value) / s.count;
    });
    
    return summary;
  }
  
  private generateAlerts(metrics: PerformanceMetric[]) {
    const alerts: string[] = [];
    
    // æ£€æŸ¥é•¿ä»»åŠ¡
    const longTasks = metrics.filter(m => m.name === 'long-task');
    if (longTasks.length > 10) {
      alerts.push(`High number of long tasks: ${longTasks.length}`);
    }
    
    // æ£€æŸ¥ CLS
    const clsMetrics = metrics.filter(m => m.name === 'cls');
    const avgCls = clsMetrics.reduce((sum, m) => sum + m.value, 0) / clsMetrics.length;
    if (avgCls > 0.1) {
      alerts.push(`High Cumulative Layout Shift: ${avgCls.toFixed(3)}`);
    }
    
    // æ£€æŸ¥èµ„æºåŠ è½½æ—¶é—´
    const resourceMetrics = metrics.filter(m => m.name === 'resource-load');
    const slowResources = resourceMetrics.filter(m => m.value > 2000);
    if (slowResources.length > 0) {
      alerts.push(`Slow resource loading detected: ${slowResources.length} resources`);
    }
    
    return alerts;
  }
  
  cleanup() {
    this.observers.forEach(observer => observer.disconnect());
    this.observers = [];
    this.metrics = [];
  }
}

export const performanceMonitor = new PerformanceMonitor();
```

## æ€»ç»“

é€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œä½ åº”è¯¥æŒæ¡ï¼š

âœ… **æ„å»ºé…ç½®ä¼˜åŒ–**
- é«˜çº§ WXT é…ç½®å’Œç¯å¢ƒç®¡ç†
- ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½ç­–ç•¥
- Bundle åˆ†æå’Œä¼˜åŒ–æŠ€å·§

âœ… **æ€§èƒ½ä¼˜åŒ–ç­–ç•¥**
- èµ„æºä¼˜åŒ–å’Œå†…å­˜ç®¡ç†
- æ€§èƒ½ç›‘æ§å’ŒæŒ‡æ ‡æ”¶é›†
- ç”¨æˆ·ä½“éªŒä¼˜åŒ–

âœ… **å¤šæµè§ˆå™¨å…¼å®¹æ€§**
- æµè§ˆå™¨ API é€‚é…ç­–ç•¥
- è‡ªåŠ¨åŒ–å¤šå¹³å°æ„å»º
- å…¼å®¹æ€§æµ‹è¯•æµç¨‹

âœ… **å‘å¸ƒæµç¨‹è‡ªåŠ¨åŒ–**
- ç‰ˆæœ¬ç®¡ç†å’Œæ›´æ–°æ—¥å¿—
- CI/CD æµæ°´çº¿é…ç½®
- åº”ç”¨å•†åº—è‡ªåŠ¨å‘å¸ƒ

âœ… **éƒ¨ç½²ç›‘æ§å’Œç»´æŠ¤**
- é”™è¯¯ç›‘æ§å’ŒæŠ¥å‘Šç³»ç»Ÿ
- æ€§èƒ½ç›‘æ§å’Œå‘Šè­¦
- ç”Ÿäº§ç¯å¢ƒç»´æŠ¤ç­–ç•¥

è‡³æ­¤ï¼Œä½ å·²ç»å®Œæˆäº† WXT æ¡†æ¶çš„å®Œæ•´å­¦ä¹ æ—…ç¨‹ï¼Œå…·å¤‡äº†å¼€å‘é«˜è´¨é‡ Chrome æ‰©å±•çš„å…¨æ ˆèƒ½åŠ›ï¼

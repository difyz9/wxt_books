# 构建部署

## WXT 扩展构建优化与部署发布

本章将深入探讨 WXT 扩展的构建优化策略、发布流程和生产环境部署的最佳实践，确保您的扩展能够高效稳定地运行。

## 构建配置优化

### 1. 高级构建配置
```typescript
// wxt.config.ts
import { defineConfig } from 'wxt';
import { resolve } from 'path';

export default defineConfig({
  // 环境配置
  outDir: 'dist',
  srcDir: 'src',
  publicDir: 'public',
  
  // 构建优化
  vite: (env) => ({
    // 基础配置
    resolve: {
      alias: {
        '@': resolve(__dirname, 'src'),
        '@/components': resolve(__dirname, 'src/components'),
        '@/utils': resolve(__dirname, 'src/utils'),
        '@/types': resolve(__dirname, 'src/types'),
        '@/hooks': resolve(__dirname, 'src/hooks'),
        '@/stores': resolve(__dirname, 'src/stores'),
        '@/assets': resolve(__dirname, 'src/assets')
      }
    },
    
    // 开发配置
    ...(env.mode === 'development' && {
      define: {
        __DEV__: true,
        __DEBUG__: true
      },
      esbuild: {
        drop: []
      }
    }),
    
    // 生产配置
    ...(env.mode === 'production' && {
      define: {
        __DEV__: false,
        __DEBUG__: false
      },
      esbuild: {
        drop: ['console', 'debugger'],
        legalComments: 'none',
        minifyIdentifiers: true,
        minifySyntax: true,
        minifyWhitespace: true
      },
      build: {
        minify: 'esbuild',
        sourcemap: false,
        rollupOptions: {
          output: {
            manualChunks: {
              vendor: ['react', 'react-dom'],
              ui: ['@headlessui/react', '@heroicons/react'],
              utils: ['lodash', 'date-fns']
            }
          }
        }
      }
    })
  }),
  
  // 扩展清单配置
  manifest: (env) => ({
    name: env.mode === 'development' ? '[DEV] TabMaster' : 'TabMaster',
    description: '高效的标签页管理工具',
    version: process.env.npm_package_version,
    
    // 权限配置
    permissions: [
      'tabs',
      'storage',
      'activeTab',
      'bookmarks',
      'history',
      'notifications'
    ],
    
    // 可选权限
    optional_permissions: [
      'background',
      'webNavigation',
      'management'
    ],
    
    // 主机权限
    host_permissions: env.mode === 'development' 
      ? ['http://localhost:*/*', 'https://localhost:*/*']
      : [],
      
    // 内容安全策略
    content_security_policy: {
      extension_pages: "script-src 'self'; object-src 'self';"
    },
    
    // Web 可访问资源
    web_accessible_resources: [
      {
        resources: ['assets/*', 'content-scripts/*'],
        matches: ['<all_urls>']
      }
    ],
    
    // 开发环境特定配置
    ...(env.mode === 'development' && {
      content_security_policy: {
        extension_pages: "script-src 'self' 'unsafe-eval'; object-src 'self';"
      }
    })
  }),
  
  // 多浏览器支持
  browser: process.env.BROWSER || 'chrome',
  
  // 自动重载配置
  reloadConfig: {
    entries: {
      contentScript: {
        paths: ['src/entrypoints/content/**/*'],
        reloadPage: true
      },
      background: {
        paths: ['src/entrypoints/background/**/*'],
        reloadExtension: true
      },
      popup: {
        paths: ['src/entrypoints/popup/**/*'],
        reloadPage: false
      }
    }
  }
});
```

### 2. 环境变量管理
```typescript
// .env.development
VITE_APP_NAME=TabMaster Dev
VITE_API_URL=http://localhost:3000/api
VITE_DEBUG=true
VITE_ANALYTICS_ID=
VITE_ERROR_REPORTING=false

// .env.production
VITE_APP_NAME=TabMaster
VITE_API_URL=https://api.tabmaster.com
VITE_DEBUG=false
VITE_ANALYTICS_ID=UA-XXXXXXXX-X
VITE_ERROR_REPORTING=true

// .env.staging
VITE_APP_NAME=TabMaster Staging
VITE_API_URL=https://staging-api.tabmaster.com
VITE_DEBUG=true
VITE_ANALYTICS_ID=UA-XXXXXXXX-Y
VITE_ERROR_REPORTING=true
```

```typescript
// src/config/env.ts
interface EnvironmentConfig {
  APP_NAME: string;
  API_URL: string;
  DEBUG: boolean;
  ANALYTICS_ID: string;
  ERROR_REPORTING: boolean;
}

const config: EnvironmentConfig = {
  APP_NAME: import.meta.env.VITE_APP_NAME,
  API_URL: import.meta.env.VITE_API_URL,
  DEBUG: import.meta.env.VITE_DEBUG === 'true',
  ANALYTICS_ID: import.meta.env.VITE_ANALYTICS_ID || '',
  ERROR_REPORTING: import.meta.env.VITE_ERROR_REPORTING === 'true'
};

// 验证必需的环境变量
const requiredEnvVars = ['VITE_APP_NAME', 'VITE_API_URL'];
const missingEnvVars = requiredEnvVars.filter(key => !import.meta.env[key]);

if (missingEnvVars.length > 0) {
  throw new Error(`Missing required environment variables: ${missingEnvVars.join(', ')}`);
}

export default config;
```

### 3. 代码分割和懒加载
```typescript
// src/entrypoints/popup/App.tsx
import React, { Suspense, lazy } from 'react';
import { ErrorBoundary } from '@/components/ErrorBoundary';
import { LoadingSpinner } from '@/components/LoadingSpinner';

// 懒加载组件
const TabManager = lazy(() => import('@/components/TabManager'));
const SettingsPanel = lazy(() => import('@/components/SettingsPanel'));
const AboutPanel = lazy(() => import('@/components/AboutPanel'));

const componentMap = {
  main: TabManager,
  settings: SettingsPanel,
  about: AboutPanel
};

interface AppProps {
  view: keyof typeof componentMap;
}

const App: React.FC<AppProps> = ({ view }) => {
  const Component = componentMap[view];
  
  return (
    <ErrorBoundary>
      <Suspense fallback={<LoadingSpinner />}>
        <Component />
      </Suspense>
    </ErrorBoundary>
  );
};

export default App;
```

```typescript
// src/utils/lazyLoader.ts
interface LazyLoaderOptions {
  timeout?: number;
  retries?: number;
  fallback?: () => Promise<any>;
}

export function createLazyLoader<T>(
  importFn: () => Promise<T>,
  options: LazyLoaderOptions = {}
) {
  const { timeout = 10000, retries = 3, fallback } = options;
  
  return async (): Promise<T> => {
    let lastError: Error;
    
    for (let attempt = 0; attempt < retries; attempt++) {
      try {
        const timeoutPromise = new Promise<never>((_, reject) => {
          setTimeout(() => reject(new Error('Import timeout')), timeout);
        });
        
        return await Promise.race([importFn(), timeoutPromise]);
      } catch (error) {
        lastError = error as Error;
        console.warn(`Import attempt ${attempt + 1} failed:`, error);
        
        // 指数退避
        if (attempt < retries - 1) {
          await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
        }
      }
    }
    
    if (fallback) {
      console.warn('Using fallback after all import attempts failed');
      return await fallback();
    }
    
    throw new Error(`Failed to import after ${retries} attempts: ${lastError.message}`);
  };
}

// 使用示例
export const LazyTabManager = lazy(createLazyLoader(
  () => import('@/components/TabManager'),
  {
    timeout: 5000,
    retries: 2,
    fallback: () => import('@/components/TabManagerFallback')
  }
));
```

## 性能优化策略

### 1. Bundle 分析和优化
```bash
# package.json scripts
{
  "scripts": {
    "build": "wxt build",
    "build:analyze": "wxt build --analyze",
    "build:stats": "wxt build --mode production --analyze --json > dist/stats.json",
    "analyze": "npx vite-bundle-analyzer dist/stats.json"
  }
}
```

```typescript
// scripts/analyze-bundle.ts
import fs from 'fs';
import path from 'path';
import { gzipSize } from 'gzip-size';

interface BundleStats {
  file: string;
  size: number;
  gzipSize: number;
  percentage: number;
}

async function analyzeBundles() {
  const distDir = path.resolve('dist');
  const files = fs.readdirSync(distDir, { recursive: true })
    .filter(file => file.toString().endsWith('.js'))
    .map(file => path.join(distDir, file.toString()));
  
  const stats: BundleStats[] = [];
  let totalSize = 0;
  
  for (const file of files) {
    const content = fs.readFileSync(file);
    const size = content.length;
    const gzipSizeBytes = await gzipSize(content);
    
    totalSize += size;
    
    stats.push({
      file: path.relative(distDir, file),
      size,
      gzipSize: gzipSizeBytes,
      percentage: 0 // 稍后计算
    });
  }
  
  // 计算百分比
  stats.forEach(stat => {
    stat.percentage = (stat.size / totalSize) * 100;
  });
  
  // 排序并输出
  stats.sort((a, b) => b.size - a.size);
  
  console.log('\n📊 Bundle Analysis Report\n');
  console.log('File'.padEnd(40) + 'Size'.padEnd(12) + 'Gzip'.padEnd(12) + 'Percentage');
  console.log('-'.repeat(80));
  
  stats.forEach(stat => {
    console.log(
      stat.file.padEnd(40) +
      formatBytes(stat.size).padEnd(12) +
      formatBytes(stat.gzipSize).padEnd(12) +
      `${stat.percentage.toFixed(1)}%`
    );
  });
  
  console.log('-'.repeat(80));
  console.log(`Total: ${formatBytes(totalSize)}`);
  
  // 检查大文件
  const largeFiles = stats.filter(stat => stat.size > 100 * 1024); // 100KB
  if (largeFiles.length > 0) {
    console.log('\n⚠️  Large files detected (>100KB):');
    largeFiles.forEach(file => {
      console.log(`  ${file.file}: ${formatBytes(file.size)}`);
    });
  }
}

function formatBytes(bytes: number): string {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}

analyzeBundles().catch(console.error);
```

### 2. 资源优化
```typescript
// src/utils/assetOptimizer.ts
class AssetOptimizer {
  private cache = new Map<string, string>();
  
  // 图片懒加载
  static createImageLoader(src: string, options: {
    placeholder?: string;
    quality?: number;
    format?: 'webp' | 'avif' | 'auto';
  } = {}) {
    return new Promise<HTMLImageElement>((resolve, reject) => {
      const img = new Image();
      
      img.onload = () => resolve(img);
      img.onerror = reject;
      
      // 添加质量和格式优化
      let optimizedSrc = src;
      if (options.quality && options.quality < 100) {
        optimizedSrc += `?quality=${options.quality}`;
      }
      
      img.src = optimizedSrc;
    });
  }
  
  // CSS 资源内联
  static async inlineCSS(cssPath: string): Promise<string> {
    try {
      const response = await fetch(chrome.runtime.getURL(cssPath));
      return await response.text();
    } catch (error) {
      console.error('Failed to inline CSS:', error);
      return '';
    }
  }
  
  // 字体预加载
  static preloadFont(fontPath: string, format = 'woff2') {
    const link = document.createElement('link');
    link.rel = 'preload';
    link.as = 'font';
    link.type = `font/${format}`;
    link.href = chrome.runtime.getURL(fontPath);
    link.crossOrigin = 'anonymous';
    
    document.head.appendChild(link);
  }
  
  // 资源预缓存
  async precacheResources(resources: string[]) {
    const promises = resources.map(async (resource) => {
      if (this.cache.has(resource)) {
        return this.cache.get(resource);
      }
      
      try {
        const response = await fetch(chrome.runtime.getURL(resource));
        const content = await response.text();
        this.cache.set(resource, content);
        return content;
      } catch (error) {
        console.error(`Failed to cache resource: ${resource}`, error);
        return null;
      }
    });
    
    return Promise.all(promises);
  }
}

// 使用示例
const optimizer = new AssetOptimizer();

// 预缓存关键资源
optimizer.precacheResources([
  'assets/icons/icon-16.png',
  'assets/icons/icon-32.png',
  'assets/styles/critical.css'
]);

// 预加载字体
AssetOptimizer.preloadFont('assets/fonts/Inter-Regular.woff2');
```

### 3. 内存管理
```typescript
// src/utils/memoryManager.ts
class MemoryManager {
  private static instance: MemoryManager;
  private intervals = new Set<number>();
  private listeners = new Set<() => void>();
  private observers = new Set<MutationObserver | IntersectionObserver>();
  
  static getInstance(): MemoryManager {
    if (!MemoryManager.instance) {
      MemoryManager.instance = new MemoryManager();
    }
    return MemoryManager.instance;
  }
  
  // 注册定时器
  registerInterval(callback: () => void, delay: number): number {
    const id = window.setInterval(callback, delay);
    this.intervals.add(id);
    return id;
  }
  
  // 注册事件监听器
  registerEventListener(
    target: EventTarget,
    event: string,
    handler: EventListener,
    options?: AddEventListenerOptions
  ): () => void {
    target.addEventListener(event, handler, options);
    
    const cleanup = () => {
      target.removeEventListener(event, handler, options);
      this.listeners.delete(cleanup);
    };
    
    this.listeners.add(cleanup);
    return cleanup;
  }
  
  // 注册观察器
  registerObserver(observer: MutationObserver | IntersectionObserver): void {
    this.observers.add(observer);
  }
  
  // 清理所有资源
  cleanup(): void {
    // 清理定时器
    this.intervals.forEach(id => clearInterval(id));
    this.intervals.clear();
    
    // 清理事件监听器
    this.listeners.forEach(cleanup => cleanup());
    this.listeners.clear();
    
    // 清理观察器
    this.observers.forEach(observer => observer.disconnect());
    this.observers.clear();
    
    console.log('Memory cleanup completed');
  }
  
  // 内存使用监控
  monitorMemoryUsage(threshold = 50 * 1024 * 1024): void { // 50MB
    const checkMemory = () => {
      if ('memory' in performance) {
        const memory = (performance as any).memory;
        const used = memory.usedJSHeapSize;
        
        if (used > threshold) {
          console.warn(`High memory usage detected: ${this.formatBytes(used)}`);
          this.suggestCleanup();
        }
      }
    };
    
    this.registerInterval(checkMemory, 30000); // 每30秒检查一次
  }
  
  private suggestCleanup(): void {
    // 清理大对象缓存
    if (window.caches) {
      caches.keys().then(keys => {
        keys.forEach(key => {
          if (key.includes('large-data')) {
            caches.delete(key);
          }
        });
      });
    }
    
    // 触发垃圾回收建议
    if (window.gc) {
      window.gc();
    }
  }
  
  private formatBytes(bytes: number): string {
    const sizes = ['B', 'KB', 'MB', 'GB'];
    if (bytes === 0) return '0 B';
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
  }
}

// 全局清理钩子
export function useMemoryCleanup() {
  const manager = MemoryManager.getInstance();
  
  useEffect(() => {
    return () => {
      manager.cleanup();
    };
  }, []);
  
  return manager;
}
```

## 多浏览器兼容性

### 1. 浏览器适配配置
```typescript
// scripts/build-multi-browser.ts
import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

const browsers = ['chrome', 'firefox', 'edge', 'safari'];

interface BrowserConfig {
  manifest: Record<string, any>;
  features: string[];
  polyfills: string[];
}

const browserConfigs: Record<string, BrowserConfig> = {
  chrome: {
    manifest: {
      manifest_version: 3,
      background: {
        service_worker: 'background.js',
        type: 'module'
      }
    },
    features: ['chrome.action', 'chrome.storage.session'],
    polyfills: []
  },
  
  firefox: {
    manifest: {
      manifest_version: 2,
      background: {
        scripts: ['background.js'],
        persistent: false
      },
      browser_action: {}, // 替代 action
      browser_specific_settings: {
        gecko: {
          id: 'tabmaster@example.com',
          strict_min_version: '109.0'
        }
      }
    },
    features: ['browser.browserAction', 'browser.storage.local'],
    polyfills: ['webextension-polyfill']
  },
  
  edge: {
    manifest: {
      manifest_version: 3,
      background: {
        service_worker: 'background.js',
        type: 'module'
      }
    },
    features: ['chrome.action', 'chrome.storage.session'],
    polyfills: []
  },
  
  safari: {
    manifest: {
      manifest_version: 2,
      background: {
        scripts: ['background.js'],
        persistent: false
      }
    },
    features: ['browser.browserAction'],
    polyfills: ['webextension-polyfill']
  }
};

async function buildForBrowser(browser: string) {
  console.log(`Building for ${browser}...`);
  
  const config = browserConfigs[browser];
  const outputDir = path.resolve(`dist-${browser}`);
  
  // 设置环境变量
  process.env.BROWSER = browser;
  process.env.TARGET_BROWSER = browser;
  
  // 构建
  execSync(`wxt build --browser ${browser} --outDir ${outputDir}`, {
    stdio: 'inherit'
  });
  
  // 后处理
  await postProcessBuild(browser, outputDir, config);
  
  console.log(`✅ ${browser} build completed`);
}

async function postProcessBuild(
  browser: string,
  outputDir: string,
  config: BrowserConfig
) {
  // 修改 manifest.json
  const manifestPath = path.join(outputDir, 'manifest.json');
  const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
  
  // 应用浏览器特定配置
  Object.assign(manifest, config.manifest);
  
  // Firefox 特殊处理
  if (browser === 'firefox') {
    // 移除不支持的字段
    delete manifest.action;
    delete manifest.background?.service_worker;
    
    // 添加 browser_action
    if (manifest.action) {
      manifest.browser_action = manifest.action;
      delete manifest.action;
    }
  }
  
  fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 2));
  
  // 添加 polyfill
  if (config.polyfills.includes('webextension-polyfill')) {
    await addWebExtensionPolyfill(outputDir);
  }
}

async function addWebExtensionPolyfill(outputDir: string) {
  const polyfillPath = require.resolve('webextension-polyfill/dist/browser-polyfill.js');
  const polyfillContent = fs.readFileSync(polyfillPath, 'utf8');
  
  // 添加 polyfill 到所有 JS 文件的开头
  const jsFiles = fs.readdirSync(outputDir)
    .filter(file => file.endsWith('.js'))
    .map(file => path.join(outputDir, file));
  
  jsFiles.forEach(filePath => {
    const content = fs.readFileSync(filePath, 'utf8');
    const withPolyfill = `${polyfillContent}\n\n${content}`;
    fs.writeFileSync(filePath, withPolyfill);
  });
}

// 构建所有浏览器版本
async function buildAll() {
  for (const browser of browsers) {
    try {
      await buildForBrowser(browser);
    } catch (error) {
      console.error(`❌ Failed to build for ${browser}:`, error);
    }
  }
  
  console.log('🎉 All builds completed');
}

buildAll().catch(console.error);
```

### 2. API 兼容性处理
```typescript
// src/utils/browserAPI.ts
interface BrowserAPI {
  tabs: typeof chrome.tabs;
  storage: typeof chrome.storage;
  runtime: typeof chrome.runtime;
  action?: typeof chrome.action;
  browserAction?: any;
}

class BrowserAPIAdapter {
  private api: BrowserAPI;
  
  constructor() {
    // 检测浏览器环境
    if (typeof browser !== 'undefined') {
      // Firefox, Safari with polyfill
      this.api = browser as any;
    } else if (typeof chrome !== 'undefined') {
      // Chrome, Edge
      this.api = chrome as any;
    } else {
      throw new Error('Unsupported browser environment');
    }
  }
  
  // 统一的 Action API
  get action() {
    if (this.api.action) {
      return this.api.action;
    } else if (this.api.browserAction) {
      // Firefox 兼容性包装
      return {
        setBadgeText: this.api.browserAction.setBadgeText.bind(this.api.browserAction),
        setBadgeBackgroundColor: this.api.browserAction.setBadgeBackgroundColor.bind(this.api.browserAction),
        setTitle: this.api.browserAction.setTitle.bind(this.api.browserAction),
        setIcon: this.api.browserAction.setIcon.bind(this.api.browserAction),
        setPopup: this.api.browserAction.setPopup.bind(this.api.browserAction),
        onClicked: this.api.browserAction.onClicked
      };
    }
    throw new Error('Action API not available');
  }
  
  // 统一的存储 API
  get storage() {
    return {
      local: {
        get: this.promisify(this.api.storage.local.get),
        set: this.promisify(this.api.storage.local.set),
        remove: this.promisify(this.api.storage.local.remove),
        clear: this.promisify(this.api.storage.local.clear)
      },
      sync: {
        get: this.promisify(this.api.storage.sync.get),
        set: this.promisify(this.api.storage.sync.set),
        remove: this.promisify(this.api.storage.sync.remove),
        clear: this.promisify(this.api.storage.sync.clear)
      }
    };
  }
  
  // 统一的标签页 API
  get tabs() {
    return {
      query: this.promisify(this.api.tabs.query),
      get: this.promisify(this.api.tabs.get),
      create: this.promisify(this.api.tabs.create),
      update: this.promisify(this.api.tabs.update),
      remove: this.promisify(this.api.tabs.remove),
      reload: this.promisify(this.api.tabs.reload),
      onActivated: this.api.tabs.onActivated,
      onUpdated: this.api.tabs.onUpdated,
      onRemoved: this.api.tabs.onRemoved
    };
  }
  
  // 统一的运行时 API
  get runtime() {
    return {
      sendMessage: this.promisify(this.api.runtime.sendMessage),
      onMessage: this.api.runtime.onMessage,
      getURL: this.api.runtime.getURL,
      onInstalled: this.api.runtime.onInstalled,
      onStartup: this.api.runtime.onStartup,
      getManifest: this.api.runtime.getManifest
    };
  }
  
  // Promise 包装器
  private promisify<T extends any[], R>(
    fn: (...args: [...T, (result: R) => void]) => void
  ) {
    return (...args: T): Promise<R> => {
      return new Promise((resolve, reject) => {
        fn(...args, (result: R) => {
          if (this.api.runtime.lastError) {
            reject(new Error(this.api.runtime.lastError.message));
          } else {
            resolve(result);
          }
        });
      });
    };
  }
  
  // 浏览器检测
  getBrowserInfo() {
    const userAgent = navigator.userAgent;
    
    if (userAgent.includes('Edg/')) {
      return { name: 'edge', version: this.extractVersion(userAgent, 'Edg/') };
    } else if (userAgent.includes('Firefox/')) {
      return { name: 'firefox', version: this.extractVersion(userAgent, 'Firefox/') };
    } else if (userAgent.includes('Safari/') && !userAgent.includes('Chrome/')) {
      return { name: 'safari', version: this.extractVersion(userAgent, 'Version/') };
    } else if (userAgent.includes('Chrome/')) {
      return { name: 'chrome', version: this.extractVersion(userAgent, 'Chrome/') };
    }
    
    return { name: 'unknown', version: '0' };
  }
  
  private extractVersion(userAgent: string, prefix: string): string {
    const index = userAgent.indexOf(prefix);
    if (index === -1) return '0';
    
    const versionStart = index + prefix.length;
    const versionEnd = userAgent.indexOf(' ', versionStart);
    return userAgent.substring(versionStart, versionEnd === -1 ? undefined : versionEnd);
  }
}

export const browserAPI = new BrowserAPIAdapter();
export default browserAPI;
```

## 发布流程自动化

### 1. 版本管理
```typescript
// scripts/version-bump.ts
import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';

type VersionType = 'patch' | 'minor' | 'major';

interface VersionConfig {
  files: string[];
  gitTag: boolean;
  changelog: boolean;
  npm: boolean;
}

const config: VersionConfig = {
  files: [
    'package.json',
    'src/manifest.json',
    'wxt.config.ts'
  ],
  gitTag: true,
  changelog: true,
  npm: false
};

function getCurrentVersion(): string {
  const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
  return packageJson.version;
}

function bumpVersion(current: string, type: VersionType): string {
  const [major, minor, patch] = current.split('.').map(Number);
  
  switch (type) {
    case 'major':
      return `${major + 1}.0.0`;
    case 'minor':
      return `${major}.${minor + 1}.0`;
    case 'patch':
      return `${major}.${minor}.${patch + 1}`;
    default:
      throw new Error(`Invalid version type: ${type}`);
  }
}

function updateVersionInFiles(newVersion: string): void {
  config.files.forEach(filePath => {
    if (!fs.existsSync(filePath)) {
      console.warn(`File not found: ${filePath}`);
      return;
    }
    
    const content = fs.readFileSync(filePath, 'utf8');
    let updatedContent: string;
    
    if (filePath.endsWith('.json')) {
      const json = JSON.parse(content);
      json.version = newVersion;
      updatedContent = JSON.stringify(json, null, 2);
    } else if (filePath.endsWith('.ts')) {
      updatedContent = content.replace(
        /version:\s*['"`][^'"`]*['"`]/g,
        `version: '${newVersion}'`
      );
    } else {
      updatedContent = content.replace(
        /version[=:]\s*['"`][^'"`]*['"`]/g,
        `version: '${newVersion}'`
      );
    }
    
    fs.writeFileSync(filePath, updatedContent);
    console.log(`✅ Updated version in ${filePath}`);
  });
}

function generateChangelog(version: string): void {
  if (!config.changelog) return;
  
  const date = new Date().toISOString().split('T')[0];
  const changelogPath = 'CHANGELOG.md';
  
  // 获取最新的 git 提交
  const commits = execSync('git log --oneline --since="1 week ago"', { encoding: 'utf8' })
    .trim()
    .split('\n')
    .filter(commit => commit.length > 0);
  
  const changelogEntry = `
## [${version}] - ${date}

### Added
- 新功能待补充

### Changed
- 改进内容待补充

### Fixed
- 修复内容待补充

### Recent Commits
${commits.map(commit => `- ${commit}`).join('\n')}

`;
  
  if (fs.existsSync(changelogPath)) {
    const existingChangelog = fs.readFileSync(changelogPath, 'utf8');
    const updatedChangelog = existingChangelog.replace(
      /^# Changelog\n/,
      `# Changelog\n${changelogEntry}`
    );
    fs.writeFileSync(changelogPath, updatedChangelog);
  } else {
    fs.writeFileSync(changelogPath, `# Changelog\n${changelogEntry}`);
  }
  
  console.log(`✅ Updated changelog`);
}

function createGitTag(version: string): void {
  if (!config.gitTag) return;
  
  try {
    execSync('git add .');
    execSync(`git commit -m "chore: bump version to ${version}"`);
    execSync(`git tag -a v${version} -m "Release version ${version}"`);
    console.log(`✅ Created git tag v${version}`);
  } catch (error) {
    console.error('Failed to create git tag:', error);
  }
}

async function main() {
  const args = process.argv.slice(2);
  const versionType = (args[0] as VersionType) || 'patch';
  
  if (!['patch', 'minor', 'major'].includes(versionType)) {
    console.error('Usage: npm run version [patch|minor|major]');
    process.exit(1);
  }
  
  const currentVersion = getCurrentVersion();
  const newVersion = bumpVersion(currentVersion, versionType);
  
  console.log(`Bumping version from ${currentVersion} to ${newVersion}`);
  
  // 更新版本号
  updateVersionInFiles(newVersion);
  
  // 生成更新日志
  generateChangelog(newVersion);
  
  // 创建 Git 标签
  createGitTag(newVersion);
  
  console.log(`🎉 Version bumped successfully to ${newVersion}`);
}

main().catch(console.error);
```

### 2. 自动化构建和发布
```yaml
# .github/workflows/release.yml
name: Release Extension

on:
  push:
    tags:
      - 'v*'

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        browser: [chrome, firefox, edge]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run tests
        run: npm test
        
      - name: Build extension
        run: npm run build:${{ matrix.browser }}
        env:
          NODE_ENV: production
          
      - name: Package extension
        run: |
          cd dist-${{ matrix.browser }}
          zip -r ../extension-${{ matrix.browser }}-${{ github.ref_name }}.zip .
          
      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: extension-${{ matrix.browser }}
          path: extension-${{ matrix.browser }}-${{ github.ref_name }}.zip
          
      - name: Create Release
        if: matrix.browser == 'chrome'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref_name }}
          release_name: Release ${{ github.ref_name }}
          draft: false
          prerelease: false
          body: |
            ## 🚀 Release Notes
            
            ### New Features
            - Add your new features here
            
            ### Improvements
            - Add your improvements here
            
            ### Bug Fixes
            - Add your bug fixes here
            
            ### Browser Support
            - ✅ Chrome
            - ✅ Firefox
            - ✅ Edge
            
            ## 📦 Downloads
            - [Chrome Extension](./extension-chrome-${{ github.ref_name }}.zip)
            - [Firefox Extension](./extension-firefox-${{ github.ref_name }}.zip)
            - [Edge Extension](./extension-edge-${{ github.ref_name }}.zip)

  deploy-chrome-store:
    needs: build-and-release
    runs-on: ubuntu-latest
    if: github.ref_type == 'tag'
    
    steps:
      - name: Download Chrome artifact
        uses: actions/download-artifact@v3
        with:
          name: extension-chrome
          
      - name: Upload to Chrome Web Store
        uses: mnao305/chrome-extension-upload@v4.0.1
        with:
          file-path: extension-chrome-${{ github.ref_name }}.zip
          extension-id: ${{ secrets.CHROME_EXTENSION_ID }}
          client-id: ${{ secrets.CHROME_CLIENT_ID }}
          client-secret: ${{ secrets.CHROME_CLIENT_SECRET }}
          refresh-token: ${{ secrets.CHROME_REFRESH_TOKEN }}
          
  deploy-firefox-store:
    needs: build-and-release
    runs-on: ubuntu-latest
    if: github.ref_type == 'tag'
    
    steps:
      - name: Download Firefox artifact
        uses: actions/download-artifact@v3
        with:
          name: extension-firefox
          
      - name: Upload to Firefox Add-ons
        uses: trmcnvn/firefox-addon@v1
        with:
          uuid: ${{ secrets.FIREFOX_EXTENSION_UUID }}
          xpi: extension-firefox-${{ github.ref_name }}.zip
          manifest: dist-firefox/manifest.json
          api-key: ${{ secrets.FIREFOX_API_KEY }}
          api-secret: ${{ secrets.FIREFOX_API_SECRET }}
```

### 3. 发布脚本
```bash
#!/bin/bash
# scripts/release.sh

set -e

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 函数定义
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# 检查必要条件
check_prerequisites() {
    log_info "Checking prerequisites..."
    
    # 检查 Git 状态
    if [[ -n $(git status --porcelain) ]]; then
        log_error "Working directory is not clean. Please commit or stash changes."
        exit 1
    fi
    
    # 检查分支
    current_branch=$(git branch --show-current)
    if [[ "$current_branch" != "main" && "$current_branch" != "master" ]]; then
        log_warn "Not on main/master branch. Current branch: $current_branch"
        read -p "Continue? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 1
        fi
    fi
    
    # 检查 npm 依赖
    if [[ ! -d "node_modules" ]]; then
        log_info "Installing dependencies..."
        npm ci
    fi
    
    log_info "Prerequisites check passed"
}

# 运行测试
run_tests() {
    log_info "Running tests..."
    
    if ! npm test; then
        log_error "Tests failed. Aborting release."
        exit 1
    fi
    
    log_info "All tests passed"
}

# 构建所有浏览器版本
build_all() {
    log_info "Building for all browsers..."
    
    local browsers=("chrome" "firefox" "edge")
    
    for browser in "${browsers[@]}"; do
        log_info "Building for $browser..."
        
        if ! npm run build:$browser; then
            log_error "Build failed for $browser"
            exit 1
        fi
        
        # 创建压缩包
        local version=$(node -p "require('./package.json').version")
        local zip_name="extension-$browser-v$version.zip"
        
        cd "dist-$browser"
        zip -r "../$zip_name" .
        cd ..
        
        log_info "Created $zip_name"
    done
    
    log_info "All builds completed"
}

# 上传到应用商店
upload_to_stores() {
    log_info "Uploading to browser stores..."
    
    # Chrome Web Store
    if [[ -n "$CHROME_EXTENSION_ID" ]]; then
        log_info "Uploading to Chrome Web Store..."
        # 这里实现 Chrome Web Store 上传逻辑
    else
        log_warn "Chrome extension ID not set, skipping Chrome Web Store upload"
    fi
    
    # Firefox Add-ons
    if [[ -n "$FIREFOX_EXTENSION_UUID" ]]; then
        log_info "Uploading to Firefox Add-ons..."
        # 这里实现 Firefox Add-ons 上传逻辑
    else
        log_warn "Firefox extension UUID not set, skipping Firefox Add-ons upload"
    fi
    
    log_info "Store uploads completed"
}

# 主函数
main() {
    local version_type=${1:-patch}
    
    log_info "Starting release process with version type: $version_type"
    
    # 检查前置条件
    check_prerequisites
    
    # 运行测试
    run_tests
    
    # 版本升级
    log_info "Bumping version..."
    npm run version:$version_type
    
    # 构建
    build_all
    
    # 推送到 Git
    log_info "Pushing to Git..."
    git push origin main --tags
    
    # 上传到应用商店（如果配置了）
    if [[ "$2" == "--upload" ]]; then
        upload_to_stores
    fi
    
    log_info "🎉 Release process completed successfully!"
}

# 脚本入口
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
```

## 部署监控和维护

### 1. 错误监控
```typescript
// src/utils/errorReporting.ts
interface ErrorReport {
  message: string;
  stack?: string;
  url: string;
  lineNumber?: number;
  columnNumber?: number;
  userAgent: string;
  version: string;
  timestamp: number;
  userId?: string;
  context?: Record<string, any>;
}

class ErrorReporter {
  private queue: ErrorReport[] = [];
  private isOnline = navigator.onLine;
  private maxQueueSize = 50;
  private reportingUrl: string;
  
  constructor(reportingUrl: string) {
    this.reportingUrl = reportingUrl;
    this.setupEventListeners();
    this.startBatchReporting();
  }
  
  private setupEventListeners() {
    // 全局错误捕获
    window.addEventListener('error', (event) => {
      this.reportError({
        message: event.message,
        stack: event.error?.stack,
        url: event.filename,
        lineNumber: event.lineno,
        columnNumber: event.colno,
        userAgent: navigator.userAgent,
        version: chrome.runtime.getManifest().version,
        timestamp: Date.now()
      });
    });
    
    // Promise 拒绝捕获
    window.addEventListener('unhandledrejection', (event) => {
      this.reportError({
        message: `Unhandled Promise Rejection: ${event.reason}`,
        stack: event.reason?.stack,
        url: window.location.href,
        userAgent: navigator.userAgent,
        version: chrome.runtime.getManifest().version,
        timestamp: Date.now()
      });
    });
    
    // 网络状态监听
    window.addEventListener('online', () => {
      this.isOnline = true;
      this.flushQueue();
    });
    
    window.addEventListener('offline', () => {
      this.isOnline = false;
    });
  }
  
  reportError(error: Partial<ErrorReport>) {
    const report: ErrorReport = {
      message: error.message || 'Unknown error',
      stack: error.stack,
      url: error.url || window.location.href,
      lineNumber: error.lineNumber,
      columnNumber: error.columnNumber,
      userAgent: navigator.userAgent,
      version: chrome.runtime.getManifest().version,
      timestamp: Date.now(),
      ...error
    };
    
    this.queue.push(report);
    
    // 限制队列大小
    if (this.queue.length > this.maxQueueSize) {
      this.queue = this.queue.slice(-this.maxQueueSize);
    }
    
    // 立即发送严重错误
    if (this.isCriticalError(report)) {
      this.sendReports([report]);
    }
  }
  
  private isCriticalError(report: ErrorReport): boolean {
    const criticalPatterns = [
      /manifest/i,
      /permission/i,
      /chrome\./i,
      /extension/i
    ];
    
    return criticalPatterns.some(pattern => 
      pattern.test(report.message) || 
      pattern.test(report.stack || '')
    );
  }
  
  private startBatchReporting() {
    setInterval(() => {
      if (this.queue.length > 0 && this.isOnline) {
        this.flushQueue();
      }
    }, 30000); // 每30秒发送一次
  }
  
  private async flushQueue() {
    if (this.queue.length === 0 || !this.isOnline) return;
    
    const reports = [...this.queue];
    this.queue = [];
    
    await this.sendReports(reports);
  }
  
  private async sendReports(reports: ErrorReport[]) {
    try {
      const response = await fetch(this.reportingUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ errors: reports })
      });
      
      if (!response.ok) {
        // 发送失败，重新加入队列
        this.queue.unshift(...reports);
      }
    } catch (error) {
      console.error('Failed to send error reports:', error);
      // 发送失败，重新加入队列
      this.queue.unshift(...reports);
    }
  }
}

// 初始化错误报告
if (import.meta.env.VITE_ERROR_REPORTING === 'true') {
  const reporter = new ErrorReporter(import.meta.env.VITE_ERROR_REPORTING_URL);
  
  // 导出全局函数
  window.__reportError = (error: any, context?: Record<string, any>) => {
    reporter.reportError({
      message: error.message || String(error),
      stack: error.stack,
      context
    });
  };
}
```

### 2. 性能监控
```typescript
// src/utils/performanceMonitor.ts
interface PerformanceMetric {
  name: string;
  value: number;
  timestamp: number;
  context?: Record<string, any>;
}

class PerformanceMonitor {
  private metrics: PerformanceMetric[] = [];
  private observers: PerformanceObserver[] = [];
  
  constructor() {
    this.setupObservers();
    this.trackVitals();
  }
  
  private setupObservers() {
    // 观察长任务
    if ('PerformanceObserver' in window) {
      const longTaskObserver = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          this.recordMetric('long-task', entry.duration, {
            startTime: entry.startTime,
            name: entry.name
          });
        }
      });
      
      try {
        longTaskObserver.observe({ entryTypes: ['longtask'] });
        this.observers.push(longTaskObserver);
      } catch (e) {
        console.warn('Long task observer not supported');
      }
    }
    
    // 观察资源加载
    const resourceObserver = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.entryType === 'resource') {
          const resourceEntry = entry as PerformanceResourceTiming;
          this.recordMetric('resource-load', resourceEntry.duration, {
            name: resourceEntry.name,
            size: resourceEntry.transferSize,
            type: resourceEntry.initiatorType
          });
        }
      }
    });
    
    try {
      resourceObserver.observe({ entryTypes: ['resource'] });
      this.observers.push(resourceObserver);
    } catch (e) {
      console.warn('Resource observer not supported');
    }
  }
  
  private trackVitals() {
    // 首次内容绘制 (FCP)
    const fcpObserver = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.name === 'first-contentful-paint') {
          this.recordMetric('fcp', entry.startTime);
        }
      }
    });
    
    try {
      fcpObserver.observe({ entryTypes: ['paint'] });
      this.observers.push(fcpObserver);
    } catch (e) {
      console.warn('Paint observer not supported');
    }
    
    // 累积布局偏移 (CLS)
    let clsValue = 0;
    const clsObserver = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (!(entry as any).hadRecentInput) {
          clsValue += (entry as any).value;
        }
      }
    });
    
    try {
      clsObserver.observe({ entryTypes: ['layout-shift'] });
      this.observers.push(clsObserver);
      
      // 定期记录 CLS
      setInterval(() => {
        if (clsValue > 0) {
          this.recordMetric('cls', clsValue);
          clsValue = 0;
        }
      }, 5000);
    } catch (e) {
      console.warn('Layout shift observer not supported');
    }
  }
  
  recordMetric(name: string, value: number, context?: Record<string, any>) {
    this.metrics.push({
      name,
      value,
      timestamp: Date.now(),
      context
    });
    
    // 限制指标数量
    if (this.metrics.length > 1000) {
      this.metrics = this.metrics.slice(-500);
    }
  }
  
  // 测量函数执行时间
  measureFunction<T>(name: string, fn: () => T): T {
    const start = performance.now();
    const result = fn();
    const end = performance.now();
    
    this.recordMetric(`function-${name}`, end - start);
    return result;
  }
  
  // 测量异步函数执行时间
  async measureAsyncFunction<T>(name: string, fn: () => Promise<T>): Promise<T> {
    const start = performance.now();
    const result = await fn();
    const end = performance.now();
    
    this.recordMetric(`async-function-${name}`, end - start);
    return result;
  }
  
  // 获取性能报告
  getPerformanceReport() {
    const now = Date.now();
    const last5Minutes = now - 5 * 60 * 1000;
    
    const recentMetrics = this.metrics.filter(m => m.timestamp > last5Minutes);
    
    const report = {
      timestamp: now,
      totalMetrics: this.metrics.length,
      recentMetrics: recentMetrics.length,
      summary: this.generateSummary(recentMetrics),
      alerts: this.generateAlerts(recentMetrics)
    };
    
    return report;
  }
  
  private generateSummary(metrics: PerformanceMetric[]) {
    const summary: Record<string, { count: number; avg: number; max: number }> = {};
    
    metrics.forEach(metric => {
      if (!summary[metric.name]) {
        summary[metric.name] = { count: 0, avg: 0, max: 0 };
      }
      
      const s = summary[metric.name];
      s.count++;
      s.max = Math.max(s.max, metric.value);
      s.avg = (s.avg * (s.count - 1) + metric.value) / s.count;
    });
    
    return summary;
  }
  
  private generateAlerts(metrics: PerformanceMetric[]) {
    const alerts: string[] = [];
    
    // 检查长任务
    const longTasks = metrics.filter(m => m.name === 'long-task');
    if (longTasks.length > 10) {
      alerts.push(`High number of long tasks: ${longTasks.length}`);
    }
    
    // 检查 CLS
    const clsMetrics = metrics.filter(m => m.name === 'cls');
    const avgCls = clsMetrics.reduce((sum, m) => sum + m.value, 0) / clsMetrics.length;
    if (avgCls > 0.1) {
      alerts.push(`High Cumulative Layout Shift: ${avgCls.toFixed(3)}`);
    }
    
    // 检查资源加载时间
    const resourceMetrics = metrics.filter(m => m.name === 'resource-load');
    const slowResources = resourceMetrics.filter(m => m.value > 2000);
    if (slowResources.length > 0) {
      alerts.push(`Slow resource loading detected: ${slowResources.length} resources`);
    }
    
    return alerts;
  }
  
  cleanup() {
    this.observers.forEach(observer => observer.disconnect());
    this.observers = [];
    this.metrics = [];
  }
}

export const performanceMonitor = new PerformanceMonitor();
```

## 总结

通过本章学习，你应该掌握：

✅ **构建配置优化**
- 高级 WXT 配置和环境管理
- 代码分割和懒加载策略
- Bundle 分析和优化技巧

✅ **性能优化策略**
- 资源优化和内存管理
- 性能监控和指标收集
- 用户体验优化

✅ **多浏览器兼容性**
- 浏览器 API 适配策略
- 自动化多平台构建
- 兼容性测试流程

✅ **发布流程自动化**
- 版本管理和更新日志
- CI/CD 流水线配置
- 应用商店自动发布

✅ **部署监控和维护**
- 错误监控和报告系统
- 性能监控和告警
- 生产环境维护策略

至此，你已经完成了 WXT 框架的完整学习旅程，具备了开发高质量 Chrome 扩展的全栈能力！

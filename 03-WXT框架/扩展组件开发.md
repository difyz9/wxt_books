# 扩展组件开发

## 扩展组件深入开发

本章将深入探讨 WXT 框架中各种扩展组件的高级开发技巧，包括 Background Script、Content Script、Popup 和 Options 页面的最佳实践，以及组件间的通信和状态管理。

## Background Script 高级开发

### 1. 服务工作线程架构
```typescript
// entrypoints/background.ts
export default defineBackground({
  type: 'module', // 使用 ES 模块
  
  main() {
    console.log('Background service worker started');
    
    // 生命周期管理
    setupLifecycleHandlers();
    
    // 消息路由
    setupMessageRouter();
    
    // API 管理
    setupAPIHandlers();
    
    // 定时任务
    setupScheduledTasks();
  }
});

// 生命周期管理
function setupLifecycleHandlers() {
  // 安装事件
  chrome.runtime.onInstalled.addListener((details) => {
    switch (details.reason) {
      case 'install':
        handleFirstInstall();
        break;
      case 'update':
        handleUpdate(details.previousVersion);
        break;
      case 'chrome_update':
        handleChromeUpdate();
        break;
    }
  });
  
  // 启动事件
  chrome.runtime.onStartup.addListener(() => {
    console.log('Extension startup');
    initializeExtension();
  });
  
  // 挂起事件 (Service Worker 特有)
  chrome.runtime.onSuspend.addListener(() => {
    console.log('Background script suspending');
    cleanupBeforeSuspend();
  });
}

async function handleFirstInstall() {
  // 初始化默认设置
  await chrome.storage.local.set({
    settings: {
      theme: 'light',
      notifications: true,
      autoSync: true
    },
    version: chrome.runtime.getManifest().version,
    installDate: Date.now()
  });
  
  // 显示欢迎页面
  chrome.tabs.create({
    url: chrome.runtime.getURL('options.html?welcome=true')
  });
}

async function handleUpdate(previousVersion?: string) {
  console.log(`Updated from ${previousVersion}`);
  
  // 数据迁移
  await migrateData(previousVersion);
  
  // 更新通知
  chrome.notifications.create({
    type: 'basic',
    iconUrl: 'icon-48.png',
    title: '扩展已更新',
    message: '发现新功能，点击查看更新日志'
  });
}
```

### 2. 消息路由系统
```typescript
// utils/messageRouter.ts
interface MessageHandler<T = any, R = any> {
  (data: T, sender: chrome.runtime.MessageSender): Promise<R> | R;
}

class MessageRouter {
  private handlers = new Map<string, MessageHandler>();
  
  constructor() {
    this.setupListener();
  }
  
  private setupListener() {
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      this.handleMessage(message, sender)
        .then(sendResponse)
        .catch(error => {
          console.error('Message handler error:', error);
          sendResponse({ error: error.message });
        });
      
      return true; // 保持消息通道开放
    });
  }
  
  register<T, R>(type: string, handler: MessageHandler<T, R>) {
    this.handlers.set(type, handler);
  }
  
  private async handleMessage(message: any, sender: chrome.runtime.MessageSender) {
    const { type, data } = message;
    const handler = this.handlers.get(type);
    
    if (!handler) {
      throw new Error(`No handler for message type: ${type}`);
    }
    
    return await handler(data, sender);
  }
}

// 使用消息路由
function setupMessageRouter() {
  const router = new MessageRouter();
  
  // 标签页管理
  router.register('GET_TABS', async () => {
    return await chrome.tabs.query({});
  });
  
  router.register('CLOSE_TAB', async (tabId: number) => {
    await chrome.tabs.remove(tabId);
    return { success: true };
  });
  
  router.register('CREATE_TAB', async (options: chrome.tabs.CreateProperties) => {
    const tab = await chrome.tabs.create(options);
    return { tab };
  });
  
  // 存储管理
  router.register('SAVE_DATA', async ({ key, value }: { key: string; value: any }) => {
    await chrome.storage.local.set({ [key]: value });
    return { success: true };
  });
  
  router.register('LOAD_DATA', async (key: string) => {
    const result = await chrome.storage.local.get([key]);
    return { data: result[key] };
  });
  
  // 权限管理
  router.register('REQUEST_PERMISSIONS', async (permissions: string[]) => {
    const granted = await chrome.permissions.request({ permissions });
    return { granted };
  });
  
  router.register('CHECK_PERMISSIONS', async (permissions: string[]) => {
    const hasPermissions = await chrome.permissions.contains({ permissions });
    return { hasPermissions };
  });
}
```

### 3. API 管理系统
```typescript
// services/apiManager.ts
class APIManager {
  private cache = new Map<string, { data: any; expiry: number }>();
  private pendingRequests = new Map<string, Promise<any>>();
  
  // 带缓存的请求
  async fetchWithCache(url: string, options: RequestInit = {}, cacheTime = 5 * 60 * 1000) {
    const cacheKey = `${url}-${JSON.stringify(options)}`;
    
    // 检查缓存
    const cached = this.cache.get(cacheKey);
    if (cached && cached.expiry > Date.now()) {
      return cached.data;
    }
    
    // 检查是否有相同的请求正在进行
    if (this.pendingRequests.has(cacheKey)) {
      return this.pendingRequests.get(cacheKey);
    }
    
    // 发起新请求
    const requestPromise = this.makeRequest(url, options);
    this.pendingRequests.set(cacheKey, requestPromise);
    
    try {
      const data = await requestPromise;
      
      // 缓存结果
      this.cache.set(cacheKey, {
        data,
        expiry: Date.now() + cacheTime
      });
      
      return data;
    } finally {
      this.pendingRequests.delete(cacheKey);
    }
  }
  
  private async makeRequest(url: string, options: RequestInit) {
    const response = await fetch(url, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    return response.json();
  }
  
  // 清除缓存
  clearCache(pattern?: string) {
    if (pattern) {
      for (const key of this.cache.keys()) {
        if (key.includes(pattern)) {
          this.cache.delete(key);
        }
      }
    } else {
      this.cache.clear();
    }
  }
}

const apiManager = new APIManager();

// API 处理器示例
function setupAPIHandlers() {
  const router = new MessageRouter();
  
  router.register('FETCH_USER_DATA', async (userId: string) => {
    return await apiManager.fetchWithCache(`/api/users/${userId}`);
  });
  
  router.register('SEARCH_DATA', async (query: string) => {
    return await apiManager.fetchWithCache(`/api/search?q=${encodeURIComponent(query)}`);
  });
}
```

### 4. 定时任务管理
```typescript
// services/scheduler.ts
class TaskScheduler {
  private alarms = new Map<string, () => void>();
  
  constructor() {
    this.setupAlarmListener();
  }
  
  private setupAlarmListener() {
    chrome.alarms.onAlarm.addListener((alarm) => {
      const handler = this.alarms.get(alarm.name);
      if (handler) {
        handler();
      }
    });
  }
  
  // 创建周期性任务
  async scheduleRecurring(name: string, intervalMinutes: number, handler: () => void) {
    this.alarms.set(name, handler);
    
    await chrome.alarms.create(name, {
      delayInMinutes: 0,
      periodInMinutes: intervalMinutes
    });
  }
  
  // 创建一次性任务
  async scheduleOnce(name: string, delayMinutes: number, handler: () => void) {
    this.alarms.set(name, () => {
      handler();
      this.alarms.delete(name); // 执行后删除
    });
    
    await chrome.alarms.create(name, {
      delayInMinutes: delayMinutes
    });
  }
  
  // 取消任务
  async cancelTask(name: string) {
    this.alarms.delete(name);
    await chrome.alarms.clear(name);
  }
  
  // 获取所有任务
  async getAllTasks() {
    return await chrome.alarms.getAll();
  }
}

function setupScheduledTasks() {
  const scheduler = new TaskScheduler();
  
  // 数据同步任务
  scheduler.scheduleRecurring('dataSync', 30, async () => {
    console.log('Syncing data...');
    await syncUserData();
  });
  
  // 清理缓存任务
  scheduler.scheduleRecurring('cleanup', 60, () => {
    console.log('Cleaning up cache...');
    apiManager.clearCache();
  });
  
  // 统计上报任务
  scheduler.scheduleRecurring('analytics', 1440, () => { // 24小时
    console.log('Sending analytics...');
    sendAnalytics();
  });
}
```

## Content Script 最佳实践

### 1. 世界隔离和注入策略
```typescript
// entrypoints/content/main.ts
export default defineContentScript({
  matches: ['<all_urls>'],
  runAt: 'document_start',
  world: 'ISOLATED', // 隔离世界，推荐
  
  main(ctx) {
    // 早期初始化
    initializeEarly();
    
    // DOM 就绪后执行
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        initializeDOM();
      });
    } else {
      initializeDOM();
    }
    
    // 页面完全加载后执行
    if (document.readyState === 'complete') {
      initializeComplete();
    } else {
      window.addEventListener('load', () => {
        initializeComplete();
      });
    }
    
    // 清理函数
    return () => {
      cleanup();
    };
  }
});

function initializeEarly() {
  console.log('Content script early init');
  
  // 阻止某些脚本执行
  if (shouldBlockScripts()) {
    blockScripts();
  }
  
  // 注入自定义样式
  injectStyles();
}

function initializeDOM() {
  console.log('DOM ready');
  
  // DOM 操作
  setupDOMObserver();
  setupEventListeners();
  injectUIElements();
}

function initializeComplete() {
  console.log('Page fully loaded');
  
  // 页面分析
  analyzePage();
  reportPageInfo();
}
```

### 2. DOM 监控和操作
```typescript
// utils/domObserver.ts
class DOMObserver {
  private observer: MutationObserver;
  private callbacks = new Map<string, (mutations: MutationRecord[]) => void>();
  
  constructor() {
    this.observer = new MutationObserver((mutations) => {
      this.handleMutations(mutations);
    });
  }
  
  start(options: MutationObserverInit = {}) {
    this.observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeOldValue: true,
      ...options
    });
  }
  
  stop() {
    this.observer.disconnect();
  }
  
  addCallback(name: string, callback: (mutations: MutationRecord[]) => void) {
    this.callbacks.set(name, callback);
  }
  
  removeCallback(name: string) {
    this.callbacks.delete(name);
  }
  
  private handleMutations(mutations: MutationRecord[]) {
    for (const callback of this.callbacks.values()) {
      try {
        callback(mutations);
      } catch (error) {
        console.error('DOM observer callback error:', error);
      }
    }
  }
}

function setupDOMObserver() {
  const observer = new DOMObserver();
  
  // 监控新增元素
  observer.addCallback('newElements', (mutations) => {
    mutations.forEach(mutation => {
      if (mutation.type === 'childList') {
        mutation.addedNodes.forEach(node => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            handleNewElement(node as Element);
          }
        });
      }
    });
  });
  
  // 监控属性变化
  observer.addCallback('attributes', (mutations) => {
    mutations.forEach(mutation => {
      if (mutation.type === 'attributes' && mutation.target instanceof Element) {
        handleAttributeChange(
          mutation.target,
          mutation.attributeName!,
          mutation.oldValue
        );
      }
    });
  });
  
  observer.start();
  
  return () => observer.stop();
}

function handleNewElement(element: Element) {
  // 处理新增的表单元素
  if (element.matches('input[type="password"]')) {
    enhancePasswordField(element as HTMLInputElement);
  }
  
  // 处理新增的链接
  if (element.matches('a[href]')) {
    enhanceLink(element as HTMLAnchorElement);
  }
  
  // 处理新增的图片
  if (element.matches('img')) {
    enhanceImage(element as HTMLImageElement);
  }
}
```

### 3. 页面内容提取和分析
```typescript
// utils/contentAnalyzer.ts
interface PageInfo {
  title: string;
  description: string;
  keywords: string[];
  links: LinkInfo[];
  images: ImageInfo[];
  forms: FormInfo[];
  performance: PerformanceInfo;
}

interface LinkInfo {
  href: string;
  text: string;
  type: 'internal' | 'external';
}

interface ImageInfo {
  src: string;
  alt: string;
  width: number;
  height: number;
}

interface FormInfo {
  action: string;
  method: string;
  inputs: string[];
}

interface PerformanceInfo {
  loadTime: number;
  domElements: number;
  scripts: number;
  stylesheets: number;
}

class ContentAnalyzer {
  analyzeCurrentPage(): PageInfo {
    return {
      title: this.getPageTitle(),
      description: this.getPageDescription(),
      keywords: this.getPageKeywords(),
      links: this.extractLinks(),
      images: this.extractImages(),
      forms: this.extractForms(),
      performance: this.getPerformanceInfo()
    };
  }
  
  private getPageTitle(): string {
    return document.title || '';
  }
  
  private getPageDescription(): string {
    const metaDesc = document.querySelector('meta[name="description"]') as HTMLMetaElement;
    return metaDesc?.content || '';
  }
  
  private getPageKeywords(): string[] {
    const metaKeywords = document.querySelector('meta[name="keywords"]') as HTMLMetaElement;
    return metaKeywords?.content.split(',').map(k => k.trim()) || [];
  }
  
  private extractLinks(): LinkInfo[] {
    const links = Array.from(document.querySelectorAll('a[href]')) as HTMLAnchorElement[];
    const currentHost = window.location.host;
    
    return links.map(link => ({
      href: link.href,
      text: link.textContent?.trim() || '',
      type: new URL(link.href).host === currentHost ? 'internal' : 'external'
    }));
  }
  
  private extractImages(): ImageInfo[] {
    const images = Array.from(document.querySelectorAll('img')) as HTMLImageElement[];
    
    return images.map(img => ({
      src: img.src,
      alt: img.alt || '',
      width: img.naturalWidth || img.width,
      height: img.naturalHeight || img.height
    }));
  }
  
  private extractForms(): FormInfo[] {
    const forms = Array.from(document.querySelectorAll('form')) as HTMLFormElement[];
    
    return forms.map(form => ({
      action: form.action,
      method: form.method,
      inputs: Array.from(form.querySelectorAll('input')).map(input => input.type)
    }));
  }
  
  private getPerformanceInfo(): PerformanceInfo {
    const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;
    
    return {
      loadTime: navigation ? navigation.loadEventEnd - navigation.loadEventStart : 0,
      domElements: document.querySelectorAll('*').length,
      scripts: document.querySelectorAll('script').length,
      stylesheets: document.querySelectorAll('link[rel="stylesheet"]').length
    };
  }
}

function analyzePage() {
  const analyzer = new ContentAnalyzer();
  const pageInfo = analyzer.analyzeCurrentPage();
  
  // 发送分析结果到背景脚本
  chrome.runtime.sendMessage({
    type: 'PAGE_ANALYZED',
    data: pageInfo
  });
}
```

### 4. 安全的页面交互
```typescript
// utils/safeInteraction.ts
class SafeInteraction {
  // 安全的元素查找
  static findElement(selector: string, timeout = 5000): Promise<Element | null> {
    return new Promise((resolve) => {
      const element = document.querySelector(selector);
      if (element) {
        resolve(element);
        return;
      }
      
      const observer = new MutationObserver(() => {
        const element = document.querySelector(selector);
        if (element) {
          observer.disconnect();
          resolve(element);
        }
      });
      
      observer.observe(document.body, {
        childList: true,
        subtree: true
      });
      
      setTimeout(() => {
        observer.disconnect();
        resolve(null);
      }, timeout);
    });
  }
  
  // 安全的事件监听
  static addSafeEventListener(
    target: EventTarget,
    event: string,
    handler: EventListener,
    options?: AddEventListenerOptions
  ) {
    const safeHandler = (e: Event) => {
      try {
        handler(e);
      } catch (error) {
        console.error('Event handler error:', error);
      }
    };
    
    target.addEventListener(event, safeHandler, options);
    
    return () => {
      target.removeEventListener(event, safeHandler, options);
    };
  }
  
  // 安全的样式注入
  static injectCSS(css: string, id?: string): HTMLStyleElement {
    const style = document.createElement('style');
    style.textContent = css;
    
    if (id) {
      style.id = id;
      // 移除已存在的相同 ID 样式
      const existing = document.getElementById(id);
      if (existing) {
        existing.remove();
      }
    }
    
    (document.head || document.documentElement).appendChild(style);
    return style;
  }
  
  // 防抖处理
  static debounce<T extends (...args: any[]) => any>(
    func: T,
    wait: number
  ): (...args: Parameters<T>) => void {
    let timeout: number;
    return (...args: Parameters<T>) => {
      clearTimeout(timeout);
      timeout = window.setTimeout(() => func(...args), wait);
    };
  }
  
  // 节流处理
  static throttle<T extends (...args: any[]) => any>(
    func: T,
    limit: number
  ): (...args: Parameters<T>) => void {
    let inThrottle: boolean;
    return (...args: Parameters<T>) => {
      if (!inThrottle) {
        func(...args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }
}
```

## Popup 页面高级开发

### 1. 响应式设计和状态管理
```typescript
// entrypoints/popup/App.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { useExtensionState } from '@/hooks/useExtensionState';
import { useChromeTabs } from '@/hooks/useChromeTabs';
import { useChromeStorage } from '@/hooks/useChromeStorage';

interface PopupState {
  view: 'main' | 'settings' | 'about';
  loading: boolean;
  error: string | null;
}

const App: React.FC = () => {
  const [state, setState] = useState<PopupState>({
    view: 'main',
    loading: true,
    error: null
  });
  
  const { tabs, loading: tabsLoading, error: tabsError } = useChromeTabs();
  const [settings, setSettings] = useChromeStorage('popup-settings', {
    compactMode: false,
    showFavicons: true,
    groupByDomain: false
  });
  
  const { extensionState, updateState } = useExtensionState();
  
  useEffect(() => {
    setState(prev => ({ ...prev, loading: false }));
  }, []);
  
  const handleViewChange = useCallback((view: PopupState['view']) => {
    setState(prev => ({ ...prev, view }));
  }, []);
  
  const handleError = useCallback((error: string) => {
    setState(prev => ({ ...prev, error }));
    setTimeout(() => {
      setState(prev => ({ ...prev, error: null }));
    }, 5000);
  }, []);
  
  if (state.loading || tabsLoading) {
    return <LoadingSpinner />;
  }
  
  return (
    <div className="w-96 max-h-96 bg-white dark:bg-gray-900 overflow-hidden">
      {/* 错误提示 */}
      {(state.error || tabsError) && (
        <ErrorBanner 
          message={state.error || tabsError} 
          onDismiss={() => handleError('')}
        />
      )}
      
      {/* 头部导航 */}
      <PopupHeader 
        currentView={state.view}
        onViewChange={handleViewChange}
      />
      
      {/* 主要内容 */}
      <div className="flex-1 overflow-y-auto">
        {state.view === 'main' && (
          <TabManager 
            tabs={tabs}
            settings={settings}
            onError={handleError}
          />
        )}
        
        {state.view === 'settings' && (
          <SettingsPanel 
            settings={settings}
            onSettingsChange={setSettings}
          />
        )}
        
        {state.view === 'about' && (
          <AboutPanel />
        )}
      </div>
    </div>
  );
};

export default App;
```

### 2. 高性能标签页管理
```typescript
// components/TabManager.tsx
import React, { useMemo, useState, useCallback } from 'react';
import { VirtualList } from '@/components/VirtualList';
import { TabItem } from '@/components/TabItem';

interface TabManagerProps {
  tabs: chrome.tabs.Tab[];
  settings: any;
  onError: (error: string) => void;
}

const TabManager: React.FC<TabManagerProps> = ({ tabs, settings, onError }) => {
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedTabs, setSelectedTabs] = useState<Set<number>>(new Set());
  
  // 过滤和分组标签页
  const processedTabs = useMemo(() => {
    let filtered = tabs.filter(tab => 
      !searchQuery || 
      tab.title?.toLowerCase().includes(searchQuery.toLowerCase()) ||
      tab.url?.toLowerCase().includes(searchQuery.toLowerCase())
    );
    
    if (settings.groupByDomain) {
      const grouped = new Map<string, chrome.tabs.Tab[]>();
      
      filtered.forEach(tab => {
        const domain = new URL(tab.url || '').hostname;
        if (!grouped.has(domain)) {
          grouped.set(domain, []);
        }
        grouped.get(domain)!.push(tab);
      });
      
      return Array.from(grouped.entries()).map(([domain, tabs]) => ({
        type: 'group' as const,
        domain,
        tabs
      }));
    }
    
    return filtered.map(tab => ({ type: 'tab' as const, tab }));
  }, [tabs, searchQuery, settings.groupByDomain]);
  
  const handleTabAction = useCallback(async (action: string, tabId: number) => {
    try {
      switch (action) {
        case 'close':
          await chrome.tabs.remove(tabId);
          break;
        case 'activate':
          await chrome.tabs.update(tabId, { active: true });
          window.close(); // 关闭弹窗
          break;
        case 'pin':
          const tab = tabs.find(t => t.id === tabId);
          await chrome.tabs.update(tabId, { pinned: !tab?.pinned });
          break;
        case 'duplicate':
          await chrome.tabs.duplicate(tabId);
          break;
      }
    } catch (error) {
      onError(`操作失败: ${error.message}`);
    }
  }, [tabs, onError]);
  
  const handleBatchAction = useCallback(async (action: string) => {
    if (selectedTabs.size === 0) return;
    
    try {
      const tabIds = Array.from(selectedTabs);
      
      switch (action) {
        case 'close':
          await chrome.tabs.remove(tabIds);
          break;
        case 'pin':
          for (const tabId of tabIds) {
            await chrome.tabs.update(tabId, { pinned: true });
          }
          break;
        case 'group':
          const groupId = await chrome.tabs.group({ tabIds });
          await chrome.tabGroups.update(groupId, { title: '新分组' });
          break;
      }
      
      setSelectedTabs(new Set());
    } catch (error) {
      onError(`批量操作失败: ${error.message}`);
    }
  }, [selectedTabs, onError]);
  
  return (
    <div className="h-full flex flex-col">
      {/* 搜索栏 */}
      <div className="p-3 border-b border-gray-200 dark:border-gray-700">
        <input
          type="text"
          placeholder="搜索标签页..."
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
        />
      </div>
      
      {/* 批量操作栏 */}
      {selectedTabs.size > 0 && (
        <div className="p-2 bg-blue-50 dark:bg-blue-900 border-b border-gray-200 dark:border-gray-700">
          <div className="flex items-center gap-2">
            <span className="text-sm text-blue-700 dark:text-blue-300">
              已选择 {selectedTabs.size} 个标签页
            </span>
            <button 
              onClick={() => handleBatchAction('close')}
              className="px-2 py-1 text-xs bg-red-500 text-white rounded hover:bg-red-600"
            >
              关闭
            </button>
            <button 
              onClick={() => handleBatchAction('pin')}
              className="px-2 py-1 text-xs bg-green-500 text-white rounded hover:bg-green-600"
            >
              固定
            </button>
            <button 
              onClick={() => setSelectedTabs(new Set())}
              className="px-2 py-1 text-xs bg-gray-500 text-white rounded hover:bg-gray-600"
            >
              取消
            </button>
          </div>
        </div>
      )}
      
      {/* 标签页列表 */}
      <div className="flex-1 overflow-hidden">
        <VirtualList
          items={processedTabs}
          itemHeight={settings.compactMode ? 40 : 60}
          renderItem={({ item, index }) => (
            item.type === 'group' ? (
              <TabGroup 
                key={`group-${item.domain}`}
                domain={item.domain}
                tabs={item.tabs}
                onTabAction={handleTabAction}
                selectedTabs={selectedTabs}
                onTabSelect={(tabId, selected) => {
                  const newSelected = new Set(selectedTabs);
                  if (selected) {
                    newSelected.add(tabId);
                  } else {
                    newSelected.delete(tabId);
                  }
                  setSelectedTabs(newSelected);
                }}
              />
            ) : (
              <TabItem
                key={`tab-${item.tab.id}`}
                tab={item.tab}
                compact={settings.compactMode}
                showFavicon={settings.showFavicons}
                selected={selectedTabs.has(item.tab.id!)}
                onAction={handleTabAction}
                onSelect={(selected) => {
                  const newSelected = new Set(selectedTabs);
                  if (selected) {
                    newSelected.add(item.tab.id!);
                  } else {
                    newSelected.delete(item.tab.id!);
                  }
                  setSelectedTabs(newSelected);
                }}
              />
            )
          )}
        />
      </div>
      
      {/* 统计信息 */}
      <div className="p-2 border-t border-gray-200 dark:border-gray-700 text-xs text-gray-500 text-center">
        共 {tabs.length} 个标签页 · {processedTabs.length} 个显示
      </div>
    </div>
  );
};
```

## Options 页面开发

### 1. 设置页面架构
```typescript
// entrypoints/options/App.tsx
import React, { useState, useEffect } from 'react';
import { SettingsProvider } from '@/contexts/SettingsContext';
import { Sidebar } from '@/components/Sidebar';
import { GeneralSettings } from '@/components/settings/GeneralSettings';
import { AdvancedSettings } from '@/components/settings/AdvancedSettings';
import { DataSettings } from '@/components/settings/DataSettings';
import { AboutSettings } from '@/components/settings/AboutSettings';

type SettingsTab = 'general' | 'advanced' | 'data' | 'about';

const App: React.FC = () => {
  const [activeTab, setActiveTab] = useState<SettingsTab>('general');
  const [isWelcome, setIsWelcome] = useState(false);
  
  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('welcome') === 'true') {
      setIsWelcome(true);
    }
  }, []);
  
  const tabs = [
    { id: 'general' as const, label: '常规设置', icon: '⚙️' },
    { id: 'advanced' as const, label: '高级设置', icon: '🔧' },
    { id: 'data' as const, label: '数据管理', icon: '💾' },
    { id: 'about' as const, label: '关于', icon: 'ℹ️' }
  ];
  
  return (
    <SettingsProvider>
      <div className="min-h-screen bg-gray-50 dark:bg-gray-900">
        {isWelcome && <WelcomeBanner onDismiss={() => setIsWelcome(false)} />}
        
        <div className="flex">
          <Sidebar 
            tabs={tabs}
            activeTab={activeTab}
            onTabChange={setActiveTab}
          />
          
          <main className="flex-1 p-8">
            <div className="max-w-4xl mx-auto">
              {activeTab === 'general' && <GeneralSettings />}
              {activeTab === 'advanced' && <AdvancedSettings />}
              {activeTab === 'data' && <DataSettings />}
              {activeTab === 'about' && <AboutSettings />}
            </div>
          </main>
        </div>
      </div>
    </SettingsProvider>
  );
};
```

### 2. 设置管理系统
```typescript
// contexts/SettingsContext.tsx
import React, { createContext, useContext, useReducer, useEffect } from 'react';

interface Settings {
  general: {
    theme: 'light' | 'dark' | 'auto';
    language: 'zh-CN' | 'en-US';
    notifications: boolean;
    autoUpdate: boolean;
  };
  advanced: {
    debugMode: boolean;
    experimentalFeatures: boolean;
    customCSS: string;
    apiEndpoint: string;
  };
  data: {
    syncEnabled: boolean;
    backupEnabled: boolean;
    retentionDays: number;
    compression: boolean;
  };
}

type SettingsAction = 
  | { type: 'LOAD_SETTINGS'; payload: Settings }
  | { type: 'UPDATE_SETTING'; path: string; value: any }
  | { type: 'RESET_SETTINGS' };

const defaultSettings: Settings = {
  general: {
    theme: 'auto',
    language: 'zh-CN',
    notifications: true,
    autoUpdate: true
  },
  advanced: {
    debugMode: false,
    experimentalFeatures: false,
    customCSS: '',
    apiEndpoint: ''
  },
  data: {
    syncEnabled: true,
    backupEnabled: true,
    retentionDays: 30,
    compression: true
  }
};

function settingsReducer(state: Settings, action: SettingsAction): Settings {
  switch (action.type) {
    case 'LOAD_SETTINGS':
      return action.payload;
      
    case 'UPDATE_SETTING': {
      const [section, key] = action.path.split('.');
      return {
        ...state,
        [section]: {
          ...state[section as keyof Settings],
          [key]: action.value
        }
      };
    }
    
    case 'RESET_SETTINGS':
      return defaultSettings;
      
    default:
      return state;
  }
}

interface SettingsContextType {
  settings: Settings;
  updateSetting: (path: string, value: any) => void;
  resetSettings: () => void;
  saveSettings: () => Promise<void>;
  loading: boolean;
  hasUnsavedChanges: boolean;
}

const SettingsContext = createContext<SettingsContextType | null>(null);

export const SettingsProvider: React.FC<{ children: React.ReactNode }> = ({ 
  children 
}) => {
  const [settings, dispatch] = useReducer(settingsReducer, defaultSettings);
  const [loading, setLoading] = useState(true);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const [savedSettings, setSavedSettings] = useState<Settings>(defaultSettings);
  
  // 加载设置
  useEffect(() => {
    const loadSettings = async () => {
      try {
        const result = await chrome.storage.sync.get(['settings']);
        const loadedSettings = result.settings || defaultSettings;
        dispatch({ type: 'LOAD_SETTINGS', payload: loadedSettings });
        setSavedSettings(loadedSettings);
      } catch (error) {
        console.error('Failed to load settings:', error);
      } finally {
        setLoading(false);
      }
    };
    
    loadSettings();
  }, []);
  
  // 检查是否有未保存的更改
  useEffect(() => {
    const hasChanges = JSON.stringify(settings) !== JSON.stringify(savedSettings);
    setHasUnsavedChanges(hasChanges);
  }, [settings, savedSettings]);
  
  const updateSetting = (path: string, value: any) => {
    dispatch({ type: 'UPDATE_SETTING', path, value });
  };
  
  const resetSettings = () => {
    dispatch({ type: 'RESET_SETTINGS' });
  };
  
  const saveSettings = async () => {
    try {
      await chrome.storage.sync.set({ settings });
      setSavedSettings(settings);
      
      // 通知背景脚本设置已更新
      chrome.runtime.sendMessage({
        type: 'SETTINGS_UPDATED',
        data: settings
      });
    } catch (error) {
      console.error('Failed to save settings:', error);
      throw error;
    }
  };
  
  const value: SettingsContextType = {
    settings,
    updateSetting,
    resetSettings,
    saveSettings,
    loading,
    hasUnsavedChanges
  };
  
  return (
    <SettingsContext.Provider value={value}>
      {children}
    </SettingsContext.Provider>
  );
};

export const useSettings = () => {
  const context = useContext(SettingsContext);
  if (!context) {
    throw new Error('useSettings must be used within SettingsProvider');
  }
  return context;
};
```

## 跨组件通信和状态管理

### 1. 消息总线系统
```typescript
// utils/messageBus.ts
type EventHandler<T = any> = (data: T) => void;

class MessageBus {
  private events = new Map<string, Set<EventHandler>>();
  private once = new Map<string, Set<EventHandler>>();
  
  // 订阅事件
  on<T>(event: string, handler: EventHandler<T>): () => void {
    if (!this.events.has(event)) {
      this.events.set(event, new Set());
    }
    
    this.events.get(event)!.add(handler);
    
    // 返回取消订阅函数
    return () => {
      this.events.get(event)?.delete(handler);
    };
  }
  
  // 一次性订阅
  once<T>(event: string, handler: EventHandler<T>): () => void {
    if (!this.once.has(event)) {
      this.once.set(event, new Set());
    }
    
    this.once.get(event)!.add(handler);
    
    return () => {
      this.once.get(event)?.delete(handler);
    };
  }
  
  // 发布事件
  emit<T>(event: string, data?: T): void {
    // 处理普通订阅
    const handlers = this.events.get(event);
    if (handlers) {
      handlers.forEach(handler => {
        try {
          handler(data);
        } catch (error) {
          console.error(`Event handler error for "${event}":`, error);
        }
      });
    }
    
    // 处理一次性订阅
    const onceHandlers = this.once.get(event);
    if (onceHandlers) {
      onceHandlers.forEach(handler => {
        try {
          handler(data);
        } catch (error) {
          console.error(`Once event handler error for "${event}":`, error);
        }
      });
      this.once.delete(event); // 执行后删除
    }
  }
  
  // 清除所有订阅
  clear(event?: string): void {
    if (event) {
      this.events.delete(event);
      this.once.delete(event);
    } else {
      this.events.clear();
      this.once.clear();
    }
  }
  
  // 获取订阅数量
  getListenerCount(event: string): number {
    const regular = this.events.get(event)?.size || 0;
    const once = this.once.get(event)?.size || 0;
    return regular + once;
  }
}

export const messageBus = new MessageBus();
```

### 2. 全局状态管理
```typescript
// stores/globalStore.ts
interface GlobalState {
  user: {
    id: string;
    name: string;
    email: string;
    preferences: UserPreferences;
  } | null;
  
  extension: {
    version: string;
    permissions: string[];
    status: 'active' | 'inactive' | 'error';
  };
  
  ui: {
    theme: 'light' | 'dark';
    sidebarOpen: boolean;
    notifications: Notification[];
  };
  
  data: {
    tabs: chrome.tabs.Tab[];
    bookmarks: chrome.bookmarks.BookmarkTreeNode[];
    history: chrome.history.HistoryItem[];
    lastSync: number;
  };
}

type StateUpdater<T> = T | ((prev: T) => T);

class GlobalStore {
  private state: GlobalState;
  private subscribers = new Set<(state: GlobalState) => void>();
  
  constructor(initialState: GlobalState) {
    this.state = initialState;
  }
  
  // 获取当前状态
  getState(): GlobalState {
    return this.state;
  }
  
  // 订阅状态变化
  subscribe(callback: (state: GlobalState) => void): () => void {
    this.subscribers.add(callback);
    
    return () => {
      this.subscribers.delete(callback);
    };
  }
  
  // 更新状态
  setState<K extends keyof GlobalState>(
    key: K,
    updater: StateUpdater<GlobalState[K]>
  ): void {
    const newValue = typeof updater === 'function' 
      ? (updater as Function)(this.state[key])
      : updater;
      
    this.state = {
      ...this.state,
      [key]: newValue
    };
    
    this.notifySubscribers();
  }
  
  // 深度更新嵌套状态
  updateNested<K extends keyof GlobalState, NK extends keyof GlobalState[K]>(
    key: K,
    nestedKey: NK,
    updater: StateUpdater<GlobalState[K][NK]>
  ): void {
    const currentNested = this.state[key] as any;
    const newValue = typeof updater === 'function'
      ? (updater as Function)(currentNested[nestedKey])
      : updater;
      
    this.setState(key, {
      ...currentNested,
      [nestedKey]: newValue
    } as GlobalState[K]);
  }
  
  private notifySubscribers(): void {
    this.subscribers.forEach(callback => {
      try {
        callback(this.state);
      } catch (error) {
        console.error('Store subscriber error:', error);
      }
    });
  }
}

const initialState: GlobalState = {
  user: null,
  extension: {
    version: chrome.runtime.getManifest().version,
    permissions: [],
    status: 'active'
  },
  ui: {
    theme: 'light',
    sidebarOpen: true,
    notifications: []
  },
  data: {
    tabs: [],
    bookmarks: [],
    history: [],
    lastSync: 0
  }
};

export const globalStore = new GlobalStore(initialState);

// React Hook
export function useGlobalStore<T>(
  selector?: (state: GlobalState) => T
): [T, GlobalStore] {
  const [state, setState] = useState(() => 
    selector ? selector(globalStore.getState()) : globalStore.getState()
  );
  
  useEffect(() => {
    const unsubscribe = globalStore.subscribe((newState) => {
      const newSelectedState = selector ? selector(newState) : newState;
      setState(newSelectedState as any);
    });
    
    return unsubscribe;
  }, [selector]);
  
  return [state, globalStore];
}
```

## 总结

通过本章学习，你应该掌握：

✅ **Background Script 高级开发**
- 服务工作线程架构设计
- 消息路由和API管理系统
- 定时任务和生命周期管理

✅ **Content Script 最佳实践**
- 安全的页面交互机制
- DOM监控和内容分析
- 性能优化和错误处理

✅ **Popup 和 Options 开发**
- 响应式界面设计
- 高性能组件开发
- 设置管理系统

✅ **跨组件通信系统**
- 消息总线实现
- 全局状态管理
- 数据同步机制

下一章我们将学习扩展的构建优化和部署发布流程。

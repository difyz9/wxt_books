# æ‰©å±•ç»„ä»¶å¼€å‘

## æ‰©å±•ç»„ä»¶æ·±å…¥å¼€å‘

æœ¬ç« å°†æ·±å…¥æ¢è®¨ WXT æ¡†æ¶ä¸­å„ç§æ‰©å±•ç»„ä»¶çš„é«˜çº§å¼€å‘æŠ€å·§ï¼ŒåŒ…æ‹¬ Background Scriptã€Content Scriptã€Popup å’Œ Options é¡µé¢çš„æœ€ä½³å®è·µï¼Œä»¥åŠç»„ä»¶é—´çš„é€šä¿¡å’ŒçŠ¶æ€ç®¡ç†ã€‚

## Background Script é«˜çº§å¼€å‘

### 1. æœåŠ¡å·¥ä½œçº¿ç¨‹æ¶æ„
```typescript
// entrypoints/background.ts
export default defineBackground({
  type: 'module', // ä½¿ç”¨ ES æ¨¡å—
  
  main() {
    console.log('Background service worker started');
    
    // ç”Ÿå‘½å‘¨æœŸç®¡ç†
    setupLifecycleHandlers();
    
    // æ¶ˆæ¯è·¯ç”±
    setupMessageRouter();
    
    // API ç®¡ç†
    setupAPIHandlers();
    
    // å®šæ—¶ä»»åŠ¡
    setupScheduledTasks();
  }
});

// ç”Ÿå‘½å‘¨æœŸç®¡ç†
function setupLifecycleHandlers() {
  // å®‰è£…äº‹ä»¶
  chrome.runtime.onInstalled.addListener((details) => {
    switch (details.reason) {
      case 'install':
        handleFirstInstall();
        break;
      case 'update':
        handleUpdate(details.previousVersion);
        break;
      case 'chrome_update':
        handleChromeUpdate();
        break;
    }
  });
  
  // å¯åŠ¨äº‹ä»¶
  chrome.runtime.onStartup.addListener(() => {
    console.log('Extension startup');
    initializeExtension();
  });
  
  // æŒ‚èµ·äº‹ä»¶ (Service Worker ç‰¹æœ‰)
  chrome.runtime.onSuspend.addListener(() => {
    console.log('Background script suspending');
    cleanupBeforeSuspend();
  });
}

async function handleFirstInstall() {
  // åˆå§‹åŒ–é»˜è®¤è®¾ç½®
  await chrome.storage.local.set({
    settings: {
      theme: 'light',
      notifications: true,
      autoSync: true
    },
    version: chrome.runtime.getManifest().version,
    installDate: Date.now()
  });
  
  // æ˜¾ç¤ºæ¬¢è¿é¡µé¢
  chrome.tabs.create({
    url: chrome.runtime.getURL('options.html?welcome=true')
  });
}

async function handleUpdate(previousVersion?: string) {
  console.log(`Updated from ${previousVersion}`);
  
  // æ•°æ®è¿ç§»
  await migrateData(previousVersion);
  
  // æ›´æ–°é€šçŸ¥
  chrome.notifications.create({
    type: 'basic',
    iconUrl: 'icon-48.png',
    title: 'æ‰©å±•å·²æ›´æ–°',
    message: 'å‘ç°æ–°åŠŸèƒ½ï¼Œç‚¹å‡»æŸ¥çœ‹æ›´æ–°æ—¥å¿—'
  });
}
```

### 2. æ¶ˆæ¯è·¯ç”±ç³»ç»Ÿ
```typescript
// utils/messageRouter.ts
interface MessageHandler<T = any, R = any> {
  (data: T, sender: chrome.runtime.MessageSender): Promise<R> | R;
}

class MessageRouter {
  private handlers = new Map<string, MessageHandler>();
  
  constructor() {
    this.setupListener();
  }
  
  private setupListener() {
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      this.handleMessage(message, sender)
        .then(sendResponse)
        .catch(error => {
          console.error('Message handler error:', error);
          sendResponse({ error: error.message });
        });
      
      return true; // ä¿æŒæ¶ˆæ¯é€šé“å¼€æ”¾
    });
  }
  
  register<T, R>(type: string, handler: MessageHandler<T, R>) {
    this.handlers.set(type, handler);
  }
  
  private async handleMessage(message: any, sender: chrome.runtime.MessageSender) {
    const { type, data } = message;
    const handler = this.handlers.get(type);
    
    if (!handler) {
      throw new Error(`No handler for message type: ${type}`);
    }
    
    return await handler(data, sender);
  }
}

// ä½¿ç”¨æ¶ˆæ¯è·¯ç”±
function setupMessageRouter() {
  const router = new MessageRouter();
  
  // æ ‡ç­¾é¡µç®¡ç†
  router.register('GET_TABS', async () => {
    return await chrome.tabs.query({});
  });
  
  router.register('CLOSE_TAB', async (tabId: number) => {
    await chrome.tabs.remove(tabId);
    return { success: true };
  });
  
  router.register('CREATE_TAB', async (options: chrome.tabs.CreateProperties) => {
    const tab = await chrome.tabs.create(options);
    return { tab };
  });
  
  // å­˜å‚¨ç®¡ç†
  router.register('SAVE_DATA', async ({ key, value }: { key: string; value: any }) => {
    await chrome.storage.local.set({ [key]: value });
    return { success: true };
  });
  
  router.register('LOAD_DATA', async (key: string) => {
    const result = await chrome.storage.local.get([key]);
    return { data: result[key] };
  });
  
  // æƒé™ç®¡ç†
  router.register('REQUEST_PERMISSIONS', async (permissions: string[]) => {
    const granted = await chrome.permissions.request({ permissions });
    return { granted };
  });
  
  router.register('CHECK_PERMISSIONS', async (permissions: string[]) => {
    const hasPermissions = await chrome.permissions.contains({ permissions });
    return { hasPermissions };
  });
}
```

### 3. API ç®¡ç†ç³»ç»Ÿ
```typescript
// services/apiManager.ts
class APIManager {
  private cache = new Map<string, { data: any; expiry: number }>();
  private pendingRequests = new Map<string, Promise<any>>();
  
  // å¸¦ç¼“å­˜çš„è¯·æ±‚
  async fetchWithCache(url: string, options: RequestInit = {}, cacheTime = 5 * 60 * 1000) {
    const cacheKey = `${url}-${JSON.stringify(options)}`;
    
    // æ£€æŸ¥ç¼“å­˜
    const cached = this.cache.get(cacheKey);
    if (cached && cached.expiry > Date.now()) {
      return cached.data;
    }
    
    // æ£€æŸ¥æ˜¯å¦æœ‰ç›¸åŒçš„è¯·æ±‚æ­£åœ¨è¿›è¡Œ
    if (this.pendingRequests.has(cacheKey)) {
      return this.pendingRequests.get(cacheKey);
    }
    
    // å‘èµ·æ–°è¯·æ±‚
    const requestPromise = this.makeRequest(url, options);
    this.pendingRequests.set(cacheKey, requestPromise);
    
    try {
      const data = await requestPromise;
      
      // ç¼“å­˜ç»“æœ
      this.cache.set(cacheKey, {
        data,
        expiry: Date.now() + cacheTime
      });
      
      return data;
    } finally {
      this.pendingRequests.delete(cacheKey);
    }
  }
  
  private async makeRequest(url: string, options: RequestInit) {
    const response = await fetch(url, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    return response.json();
  }
  
  // æ¸…é™¤ç¼“å­˜
  clearCache(pattern?: string) {
    if (pattern) {
      for (const key of this.cache.keys()) {
        if (key.includes(pattern)) {
          this.cache.delete(key);
        }
      }
    } else {
      this.cache.clear();
    }
  }
}

const apiManager = new APIManager();

// API å¤„ç†å™¨ç¤ºä¾‹
function setupAPIHandlers() {
  const router = new MessageRouter();
  
  router.register('FETCH_USER_DATA', async (userId: string) => {
    return await apiManager.fetchWithCache(`/api/users/${userId}`);
  });
  
  router.register('SEARCH_DATA', async (query: string) => {
    return await apiManager.fetchWithCache(`/api/search?q=${encodeURIComponent(query)}`);
  });
}
```

### 4. å®šæ—¶ä»»åŠ¡ç®¡ç†
```typescript
// services/scheduler.ts
class TaskScheduler {
  private alarms = new Map<string, () => void>();
  
  constructor() {
    this.setupAlarmListener();
  }
  
  private setupAlarmListener() {
    chrome.alarms.onAlarm.addListener((alarm) => {
      const handler = this.alarms.get(alarm.name);
      if (handler) {
        handler();
      }
    });
  }
  
  // åˆ›å»ºå‘¨æœŸæ€§ä»»åŠ¡
  async scheduleRecurring(name: string, intervalMinutes: number, handler: () => void) {
    this.alarms.set(name, handler);
    
    await chrome.alarms.create(name, {
      delayInMinutes: 0,
      periodInMinutes: intervalMinutes
    });
  }
  
  // åˆ›å»ºä¸€æ¬¡æ€§ä»»åŠ¡
  async scheduleOnce(name: string, delayMinutes: number, handler: () => void) {
    this.alarms.set(name, () => {
      handler();
      this.alarms.delete(name); // æ‰§è¡Œååˆ é™¤
    });
    
    await chrome.alarms.create(name, {
      delayInMinutes: delayMinutes
    });
  }
  
  // å–æ¶ˆä»»åŠ¡
  async cancelTask(name: string) {
    this.alarms.delete(name);
    await chrome.alarms.clear(name);
  }
  
  // è·å–æ‰€æœ‰ä»»åŠ¡
  async getAllTasks() {
    return await chrome.alarms.getAll();
  }
}

function setupScheduledTasks() {
  const scheduler = new TaskScheduler();
  
  // æ•°æ®åŒæ­¥ä»»åŠ¡
  scheduler.scheduleRecurring('dataSync', 30, async () => {
    console.log('Syncing data...');
    await syncUserData();
  });
  
  // æ¸…ç†ç¼“å­˜ä»»åŠ¡
  scheduler.scheduleRecurring('cleanup', 60, () => {
    console.log('Cleaning up cache...');
    apiManager.clearCache();
  });
  
  // ç»Ÿè®¡ä¸ŠæŠ¥ä»»åŠ¡
  scheduler.scheduleRecurring('analytics', 1440, () => { // 24å°æ—¶
    console.log('Sending analytics...');
    sendAnalytics();
  });
}
```

## Content Script æœ€ä½³å®è·µ

### 1. ä¸–ç•Œéš”ç¦»å’Œæ³¨å…¥ç­–ç•¥
```typescript
// entrypoints/content/main.ts
export default defineContentScript({
  matches: ['<all_urls>'],
  runAt: 'document_start',
  world: 'ISOLATED', // éš”ç¦»ä¸–ç•Œï¼Œæ¨è
  
  main(ctx) {
    // æ—©æœŸåˆå§‹åŒ–
    initializeEarly();
    
    // DOM å°±ç»ªåæ‰§è¡Œ
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        initializeDOM();
      });
    } else {
      initializeDOM();
    }
    
    // é¡µé¢å®Œå…¨åŠ è½½åæ‰§è¡Œ
    if (document.readyState === 'complete') {
      initializeComplete();
    } else {
      window.addEventListener('load', () => {
        initializeComplete();
      });
    }
    
    // æ¸…ç†å‡½æ•°
    return () => {
      cleanup();
    };
  }
});

function initializeEarly() {
  console.log('Content script early init');
  
  // é˜»æ­¢æŸäº›è„šæœ¬æ‰§è¡Œ
  if (shouldBlockScripts()) {
    blockScripts();
  }
  
  // æ³¨å…¥è‡ªå®šä¹‰æ ·å¼
  injectStyles();
}

function initializeDOM() {
  console.log('DOM ready');
  
  // DOM æ“ä½œ
  setupDOMObserver();
  setupEventListeners();
  injectUIElements();
}

function initializeComplete() {
  console.log('Page fully loaded');
  
  // é¡µé¢åˆ†æ
  analyzePage();
  reportPageInfo();
}
```

### 2. DOM ç›‘æ§å’Œæ“ä½œ
```typescript
// utils/domObserver.ts
class DOMObserver {
  private observer: MutationObserver;
  private callbacks = new Map<string, (mutations: MutationRecord[]) => void>();
  
  constructor() {
    this.observer = new MutationObserver((mutations) => {
      this.handleMutations(mutations);
    });
  }
  
  start(options: MutationObserverInit = {}) {
    this.observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeOldValue: true,
      ...options
    });
  }
  
  stop() {
    this.observer.disconnect();
  }
  
  addCallback(name: string, callback: (mutations: MutationRecord[]) => void) {
    this.callbacks.set(name, callback);
  }
  
  removeCallback(name: string) {
    this.callbacks.delete(name);
  }
  
  private handleMutations(mutations: MutationRecord[]) {
    for (const callback of this.callbacks.values()) {
      try {
        callback(mutations);
      } catch (error) {
        console.error('DOM observer callback error:', error);
      }
    }
  }
}

function setupDOMObserver() {
  const observer = new DOMObserver();
  
  // ç›‘æ§æ–°å¢å…ƒç´ 
  observer.addCallback('newElements', (mutations) => {
    mutations.forEach(mutation => {
      if (mutation.type === 'childList') {
        mutation.addedNodes.forEach(node => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            handleNewElement(node as Element);
          }
        });
      }
    });
  });
  
  // ç›‘æ§å±æ€§å˜åŒ–
  observer.addCallback('attributes', (mutations) => {
    mutations.forEach(mutation => {
      if (mutation.type === 'attributes' && mutation.target instanceof Element) {
        handleAttributeChange(
          mutation.target,
          mutation.attributeName!,
          mutation.oldValue
        );
      }
    });
  });
  
  observer.start();
  
  return () => observer.stop();
}

function handleNewElement(element: Element) {
  // å¤„ç†æ–°å¢çš„è¡¨å•å…ƒç´ 
  if (element.matches('input[type="password"]')) {
    enhancePasswordField(element as HTMLInputElement);
  }
  
  // å¤„ç†æ–°å¢çš„é“¾æ¥
  if (element.matches('a[href]')) {
    enhanceLink(element as HTMLAnchorElement);
  }
  
  // å¤„ç†æ–°å¢çš„å›¾ç‰‡
  if (element.matches('img')) {
    enhanceImage(element as HTMLImageElement);
  }
}
```

### 3. é¡µé¢å†…å®¹æå–å’Œåˆ†æ
```typescript
// utils/contentAnalyzer.ts
interface PageInfo {
  title: string;
  description: string;
  keywords: string[];
  links: LinkInfo[];
  images: ImageInfo[];
  forms: FormInfo[];
  performance: PerformanceInfo;
}

interface LinkInfo {
  href: string;
  text: string;
  type: 'internal' | 'external';
}

interface ImageInfo {
  src: string;
  alt: string;
  width: number;
  height: number;
}

interface FormInfo {
  action: string;
  method: string;
  inputs: string[];
}

interface PerformanceInfo {
  loadTime: number;
  domElements: number;
  scripts: number;
  stylesheets: number;
}

class ContentAnalyzer {
  analyzeCurrentPage(): PageInfo {
    return {
      title: this.getPageTitle(),
      description: this.getPageDescription(),
      keywords: this.getPageKeywords(),
      links: this.extractLinks(),
      images: this.extractImages(),
      forms: this.extractForms(),
      performance: this.getPerformanceInfo()
    };
  }
  
  private getPageTitle(): string {
    return document.title || '';
  }
  
  private getPageDescription(): string {
    const metaDesc = document.querySelector('meta[name="description"]') as HTMLMetaElement;
    return metaDesc?.content || '';
  }
  
  private getPageKeywords(): string[] {
    const metaKeywords = document.querySelector('meta[name="keywords"]') as HTMLMetaElement;
    return metaKeywords?.content.split(',').map(k => k.trim()) || [];
  }
  
  private extractLinks(): LinkInfo[] {
    const links = Array.from(document.querySelectorAll('a[href]')) as HTMLAnchorElement[];
    const currentHost = window.location.host;
    
    return links.map(link => ({
      href: link.href,
      text: link.textContent?.trim() || '',
      type: new URL(link.href).host === currentHost ? 'internal' : 'external'
    }));
  }
  
  private extractImages(): ImageInfo[] {
    const images = Array.from(document.querySelectorAll('img')) as HTMLImageElement[];
    
    return images.map(img => ({
      src: img.src,
      alt: img.alt || '',
      width: img.naturalWidth || img.width,
      height: img.naturalHeight || img.height
    }));
  }
  
  private extractForms(): FormInfo[] {
    const forms = Array.from(document.querySelectorAll('form')) as HTMLFormElement[];
    
    return forms.map(form => ({
      action: form.action,
      method: form.method,
      inputs: Array.from(form.querySelectorAll('input')).map(input => input.type)
    }));
  }
  
  private getPerformanceInfo(): PerformanceInfo {
    const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;
    
    return {
      loadTime: navigation ? navigation.loadEventEnd - navigation.loadEventStart : 0,
      domElements: document.querySelectorAll('*').length,
      scripts: document.querySelectorAll('script').length,
      stylesheets: document.querySelectorAll('link[rel="stylesheet"]').length
    };
  }
}

function analyzePage() {
  const analyzer = new ContentAnalyzer();
  const pageInfo = analyzer.analyzeCurrentPage();
  
  // å‘é€åˆ†æç»“æœåˆ°èƒŒæ™¯è„šæœ¬
  chrome.runtime.sendMessage({
    type: 'PAGE_ANALYZED',
    data: pageInfo
  });
}
```

### 4. å®‰å…¨çš„é¡µé¢äº¤äº’
```typescript
// utils/safeInteraction.ts
class SafeInteraction {
  // å®‰å…¨çš„å…ƒç´ æŸ¥æ‰¾
  static findElement(selector: string, timeout = 5000): Promise<Element | null> {
    return new Promise((resolve) => {
      const element = document.querySelector(selector);
      if (element) {
        resolve(element);
        return;
      }
      
      const observer = new MutationObserver(() => {
        const element = document.querySelector(selector);
        if (element) {
          observer.disconnect();
          resolve(element);
        }
      });
      
      observer.observe(document.body, {
        childList: true,
        subtree: true
      });
      
      setTimeout(() => {
        observer.disconnect();
        resolve(null);
      }, timeout);
    });
  }
  
  // å®‰å…¨çš„äº‹ä»¶ç›‘å¬
  static addSafeEventListener(
    target: EventTarget,
    event: string,
    handler: EventListener,
    options?: AddEventListenerOptions
  ) {
    const safeHandler = (e: Event) => {
      try {
        handler(e);
      } catch (error) {
        console.error('Event handler error:', error);
      }
    };
    
    target.addEventListener(event, safeHandler, options);
    
    return () => {
      target.removeEventListener(event, safeHandler, options);
    };
  }
  
  // å®‰å…¨çš„æ ·å¼æ³¨å…¥
  static injectCSS(css: string, id?: string): HTMLStyleElement {
    const style = document.createElement('style');
    style.textContent = css;
    
    if (id) {
      style.id = id;
      // ç§»é™¤å·²å­˜åœ¨çš„ç›¸åŒ ID æ ·å¼
      const existing = document.getElementById(id);
      if (existing) {
        existing.remove();
      }
    }
    
    (document.head || document.documentElement).appendChild(style);
    return style;
  }
  
  // é˜²æŠ–å¤„ç†
  static debounce<T extends (...args: any[]) => any>(
    func: T,
    wait: number
  ): (...args: Parameters<T>) => void {
    let timeout: number;
    return (...args: Parameters<T>) => {
      clearTimeout(timeout);
      timeout = window.setTimeout(() => func(...args), wait);
    };
  }
  
  // èŠ‚æµå¤„ç†
  static throttle<T extends (...args: any[]) => any>(
    func: T,
    limit: number
  ): (...args: Parameters<T>) => void {
    let inThrottle: boolean;
    return (...args: Parameters<T>) => {
      if (!inThrottle) {
        func(...args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }
}
```

## Popup é¡µé¢é«˜çº§å¼€å‘

### 1. å“åº”å¼è®¾è®¡å’ŒçŠ¶æ€ç®¡ç†
```typescript
// entrypoints/popup/App.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { useExtensionState } from '@/hooks/useExtensionState';
import { useChromeTabs } from '@/hooks/useChromeTabs';
import { useChromeStorage } from '@/hooks/useChromeStorage';

interface PopupState {
  view: 'main' | 'settings' | 'about';
  loading: boolean;
  error: string | null;
}

const App: React.FC = () => {
  const [state, setState] = useState<PopupState>({
    view: 'main',
    loading: true,
    error: null
  });
  
  const { tabs, loading: tabsLoading, error: tabsError } = useChromeTabs();
  const [settings, setSettings] = useChromeStorage('popup-settings', {
    compactMode: false,
    showFavicons: true,
    groupByDomain: false
  });
  
  const { extensionState, updateState } = useExtensionState();
  
  useEffect(() => {
    setState(prev => ({ ...prev, loading: false }));
  }, []);
  
  const handleViewChange = useCallback((view: PopupState['view']) => {
    setState(prev => ({ ...prev, view }));
  }, []);
  
  const handleError = useCallback((error: string) => {
    setState(prev => ({ ...prev, error }));
    setTimeout(() => {
      setState(prev => ({ ...prev, error: null }));
    }, 5000);
  }, []);
  
  if (state.loading || tabsLoading) {
    return <LoadingSpinner />;
  }
  
  return (
    <div className="w-96 max-h-96 bg-white dark:bg-gray-900 overflow-hidden">
      {/* é”™è¯¯æç¤º */}
      {(state.error || tabsError) && (
        <ErrorBanner 
          message={state.error || tabsError} 
          onDismiss={() => handleError('')}
        />
      )}
      
      {/* å¤´éƒ¨å¯¼èˆª */}
      <PopupHeader 
        currentView={state.view}
        onViewChange={handleViewChange}
      />
      
      {/* ä¸»è¦å†…å®¹ */}
      <div className="flex-1 overflow-y-auto">
        {state.view === 'main' && (
          <TabManager 
            tabs={tabs}
            settings={settings}
            onError={handleError}
          />
        )}
        
        {state.view === 'settings' && (
          <SettingsPanel 
            settings={settings}
            onSettingsChange={setSettings}
          />
        )}
        
        {state.view === 'about' && (
          <AboutPanel />
        )}
      </div>
    </div>
  );
};

export default App;
```

### 2. é«˜æ€§èƒ½æ ‡ç­¾é¡µç®¡ç†
```typescript
// components/TabManager.tsx
import React, { useMemo, useState, useCallback } from 'react';
import { VirtualList } from '@/components/VirtualList';
import { TabItem } from '@/components/TabItem';

interface TabManagerProps {
  tabs: chrome.tabs.Tab[];
  settings: any;
  onError: (error: string) => void;
}

const TabManager: React.FC<TabManagerProps> = ({ tabs, settings, onError }) => {
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedTabs, setSelectedTabs] = useState<Set<number>>(new Set());
  
  // è¿‡æ»¤å’Œåˆ†ç»„æ ‡ç­¾é¡µ
  const processedTabs = useMemo(() => {
    let filtered = tabs.filter(tab => 
      !searchQuery || 
      tab.title?.toLowerCase().includes(searchQuery.toLowerCase()) ||
      tab.url?.toLowerCase().includes(searchQuery.toLowerCase())
    );
    
    if (settings.groupByDomain) {
      const grouped = new Map<string, chrome.tabs.Tab[]>();
      
      filtered.forEach(tab => {
        const domain = new URL(tab.url || '').hostname;
        if (!grouped.has(domain)) {
          grouped.set(domain, []);
        }
        grouped.get(domain)!.push(tab);
      });
      
      return Array.from(grouped.entries()).map(([domain, tabs]) => ({
        type: 'group' as const,
        domain,
        tabs
      }));
    }
    
    return filtered.map(tab => ({ type: 'tab' as const, tab }));
  }, [tabs, searchQuery, settings.groupByDomain]);
  
  const handleTabAction = useCallback(async (action: string, tabId: number) => {
    try {
      switch (action) {
        case 'close':
          await chrome.tabs.remove(tabId);
          break;
        case 'activate':
          await chrome.tabs.update(tabId, { active: true });
          window.close(); // å…³é—­å¼¹çª—
          break;
        case 'pin':
          const tab = tabs.find(t => t.id === tabId);
          await chrome.tabs.update(tabId, { pinned: !tab?.pinned });
          break;
        case 'duplicate':
          await chrome.tabs.duplicate(tabId);
          break;
      }
    } catch (error) {
      onError(`æ“ä½œå¤±è´¥: ${error.message}`);
    }
  }, [tabs, onError]);
  
  const handleBatchAction = useCallback(async (action: string) => {
    if (selectedTabs.size === 0) return;
    
    try {
      const tabIds = Array.from(selectedTabs);
      
      switch (action) {
        case 'close':
          await chrome.tabs.remove(tabIds);
          break;
        case 'pin':
          for (const tabId of tabIds) {
            await chrome.tabs.update(tabId, { pinned: true });
          }
          break;
        case 'group':
          const groupId = await chrome.tabs.group({ tabIds });
          await chrome.tabGroups.update(groupId, { title: 'æ–°åˆ†ç»„' });
          break;
      }
      
      setSelectedTabs(new Set());
    } catch (error) {
      onError(`æ‰¹é‡æ“ä½œå¤±è´¥: ${error.message}`);
    }
  }, [selectedTabs, onError]);
  
  return (
    <div className="h-full flex flex-col">
      {/* æœç´¢æ  */}
      <div className="p-3 border-b border-gray-200 dark:border-gray-700">
        <input
          type="text"
          placeholder="æœç´¢æ ‡ç­¾é¡µ..."
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
        />
      </div>
      
      {/* æ‰¹é‡æ“ä½œæ  */}
      {selectedTabs.size > 0 && (
        <div className="p-2 bg-blue-50 dark:bg-blue-900 border-b border-gray-200 dark:border-gray-700">
          <div className="flex items-center gap-2">
            <span className="text-sm text-blue-700 dark:text-blue-300">
              å·²é€‰æ‹© {selectedTabs.size} ä¸ªæ ‡ç­¾é¡µ
            </span>
            <button 
              onClick={() => handleBatchAction('close')}
              className="px-2 py-1 text-xs bg-red-500 text-white rounded hover:bg-red-600"
            >
              å…³é—­
            </button>
            <button 
              onClick={() => handleBatchAction('pin')}
              className="px-2 py-1 text-xs bg-green-500 text-white rounded hover:bg-green-600"
            >
              å›ºå®š
            </button>
            <button 
              onClick={() => setSelectedTabs(new Set())}
              className="px-2 py-1 text-xs bg-gray-500 text-white rounded hover:bg-gray-600"
            >
              å–æ¶ˆ
            </button>
          </div>
        </div>
      )}
      
      {/* æ ‡ç­¾é¡µåˆ—è¡¨ */}
      <div className="flex-1 overflow-hidden">
        <VirtualList
          items={processedTabs}
          itemHeight={settings.compactMode ? 40 : 60}
          renderItem={({ item, index }) => (
            item.type === 'group' ? (
              <TabGroup 
                key={`group-${item.domain}`}
                domain={item.domain}
                tabs={item.tabs}
                onTabAction={handleTabAction}
                selectedTabs={selectedTabs}
                onTabSelect={(tabId, selected) => {
                  const newSelected = new Set(selectedTabs);
                  if (selected) {
                    newSelected.add(tabId);
                  } else {
                    newSelected.delete(tabId);
                  }
                  setSelectedTabs(newSelected);
                }}
              />
            ) : (
              <TabItem
                key={`tab-${item.tab.id}`}
                tab={item.tab}
                compact={settings.compactMode}
                showFavicon={settings.showFavicons}
                selected={selectedTabs.has(item.tab.id!)}
                onAction={handleTabAction}
                onSelect={(selected) => {
                  const newSelected = new Set(selectedTabs);
                  if (selected) {
                    newSelected.add(item.tab.id!);
                  } else {
                    newSelected.delete(item.tab.id!);
                  }
                  setSelectedTabs(newSelected);
                }}
              />
            )
          )}
        />
      </div>
      
      {/* ç»Ÿè®¡ä¿¡æ¯ */}
      <div className="p-2 border-t border-gray-200 dark:border-gray-700 text-xs text-gray-500 text-center">
        å…± {tabs.length} ä¸ªæ ‡ç­¾é¡µ Â· {processedTabs.length} ä¸ªæ˜¾ç¤º
      </div>
    </div>
  );
};
```

## Options é¡µé¢å¼€å‘

### 1. è®¾ç½®é¡µé¢æ¶æ„
```typescript
// entrypoints/options/App.tsx
import React, { useState, useEffect } from 'react';
import { SettingsProvider } from '@/contexts/SettingsContext';
import { Sidebar } from '@/components/Sidebar';
import { GeneralSettings } from '@/components/settings/GeneralSettings';
import { AdvancedSettings } from '@/components/settings/AdvancedSettings';
import { DataSettings } from '@/components/settings/DataSettings';
import { AboutSettings } from '@/components/settings/AboutSettings';

type SettingsTab = 'general' | 'advanced' | 'data' | 'about';

const App: React.FC = () => {
  const [activeTab, setActiveTab] = useState<SettingsTab>('general');
  const [isWelcome, setIsWelcome] = useState(false);
  
  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('welcome') === 'true') {
      setIsWelcome(true);
    }
  }, []);
  
  const tabs = [
    { id: 'general' as const, label: 'å¸¸è§„è®¾ç½®', icon: 'âš™ï¸' },
    { id: 'advanced' as const, label: 'é«˜çº§è®¾ç½®', icon: 'ğŸ”§' },
    { id: 'data' as const, label: 'æ•°æ®ç®¡ç†', icon: 'ğŸ’¾' },
    { id: 'about' as const, label: 'å…³äº', icon: 'â„¹ï¸' }
  ];
  
  return (
    <SettingsProvider>
      <div className="min-h-screen bg-gray-50 dark:bg-gray-900">
        {isWelcome && <WelcomeBanner onDismiss={() => setIsWelcome(false)} />}
        
        <div className="flex">
          <Sidebar 
            tabs={tabs}
            activeTab={activeTab}
            onTabChange={setActiveTab}
          />
          
          <main className="flex-1 p-8">
            <div className="max-w-4xl mx-auto">
              {activeTab === 'general' && <GeneralSettings />}
              {activeTab === 'advanced' && <AdvancedSettings />}
              {activeTab === 'data' && <DataSettings />}
              {activeTab === 'about' && <AboutSettings />}
            </div>
          </main>
        </div>
      </div>
    </SettingsProvider>
  );
};
```

### 2. è®¾ç½®ç®¡ç†ç³»ç»Ÿ
```typescript
// contexts/SettingsContext.tsx
import React, { createContext, useContext, useReducer, useEffect } from 'react';

interface Settings {
  general: {
    theme: 'light' | 'dark' | 'auto';
    language: 'zh-CN' | 'en-US';
    notifications: boolean;
    autoUpdate: boolean;
  };
  advanced: {
    debugMode: boolean;
    experimentalFeatures: boolean;
    customCSS: string;
    apiEndpoint: string;
  };
  data: {
    syncEnabled: boolean;
    backupEnabled: boolean;
    retentionDays: number;
    compression: boolean;
  };
}

type SettingsAction = 
  | { type: 'LOAD_SETTINGS'; payload: Settings }
  | { type: 'UPDATE_SETTING'; path: string; value: any }
  | { type: 'RESET_SETTINGS' };

const defaultSettings: Settings = {
  general: {
    theme: 'auto',
    language: 'zh-CN',
    notifications: true,
    autoUpdate: true
  },
  advanced: {
    debugMode: false,
    experimentalFeatures: false,
    customCSS: '',
    apiEndpoint: ''
  },
  data: {
    syncEnabled: true,
    backupEnabled: true,
    retentionDays: 30,
    compression: true
  }
};

function settingsReducer(state: Settings, action: SettingsAction): Settings {
  switch (action.type) {
    case 'LOAD_SETTINGS':
      return action.payload;
      
    case 'UPDATE_SETTING': {
      const [section, key] = action.path.split('.');
      return {
        ...state,
        [section]: {
          ...state[section as keyof Settings],
          [key]: action.value
        }
      };
    }
    
    case 'RESET_SETTINGS':
      return defaultSettings;
      
    default:
      return state;
  }
}

interface SettingsContextType {
  settings: Settings;
  updateSetting: (path: string, value: any) => void;
  resetSettings: () => void;
  saveSettings: () => Promise<void>;
  loading: boolean;
  hasUnsavedChanges: boolean;
}

const SettingsContext = createContext<SettingsContextType | null>(null);

export const SettingsProvider: React.FC<{ children: React.ReactNode }> = ({ 
  children 
}) => {
  const [settings, dispatch] = useReducer(settingsReducer, defaultSettings);
  const [loading, setLoading] = useState(true);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const [savedSettings, setSavedSettings] = useState<Settings>(defaultSettings);
  
  // åŠ è½½è®¾ç½®
  useEffect(() => {
    const loadSettings = async () => {
      try {
        const result = await chrome.storage.sync.get(['settings']);
        const loadedSettings = result.settings || defaultSettings;
        dispatch({ type: 'LOAD_SETTINGS', payload: loadedSettings });
        setSavedSettings(loadedSettings);
      } catch (error) {
        console.error('Failed to load settings:', error);
      } finally {
        setLoading(false);
      }
    };
    
    loadSettings();
  }, []);
  
  // æ£€æŸ¥æ˜¯å¦æœ‰æœªä¿å­˜çš„æ›´æ”¹
  useEffect(() => {
    const hasChanges = JSON.stringify(settings) !== JSON.stringify(savedSettings);
    setHasUnsavedChanges(hasChanges);
  }, [settings, savedSettings]);
  
  const updateSetting = (path: string, value: any) => {
    dispatch({ type: 'UPDATE_SETTING', path, value });
  };
  
  const resetSettings = () => {
    dispatch({ type: 'RESET_SETTINGS' });
  };
  
  const saveSettings = async () => {
    try {
      await chrome.storage.sync.set({ settings });
      setSavedSettings(settings);
      
      // é€šçŸ¥èƒŒæ™¯è„šæœ¬è®¾ç½®å·²æ›´æ–°
      chrome.runtime.sendMessage({
        type: 'SETTINGS_UPDATED',
        data: settings
      });
    } catch (error) {
      console.error('Failed to save settings:', error);
      throw error;
    }
  };
  
  const value: SettingsContextType = {
    settings,
    updateSetting,
    resetSettings,
    saveSettings,
    loading,
    hasUnsavedChanges
  };
  
  return (
    <SettingsContext.Provider value={value}>
      {children}
    </SettingsContext.Provider>
  );
};

export const useSettings = () => {
  const context = useContext(SettingsContext);
  if (!context) {
    throw new Error('useSettings must be used within SettingsProvider');
  }
  return context;
};
```

## è·¨ç»„ä»¶é€šä¿¡å’ŒçŠ¶æ€ç®¡ç†

### 1. æ¶ˆæ¯æ€»çº¿ç³»ç»Ÿ
```typescript
// utils/messageBus.ts
type EventHandler<T = any> = (data: T) => void;

class MessageBus {
  private events = new Map<string, Set<EventHandler>>();
  private once = new Map<string, Set<EventHandler>>();
  
  // è®¢é˜…äº‹ä»¶
  on<T>(event: string, handler: EventHandler<T>): () => void {
    if (!this.events.has(event)) {
      this.events.set(event, new Set());
    }
    
    this.events.get(event)!.add(handler);
    
    // è¿”å›å–æ¶ˆè®¢é˜…å‡½æ•°
    return () => {
      this.events.get(event)?.delete(handler);
    };
  }
  
  // ä¸€æ¬¡æ€§è®¢é˜…
  once<T>(event: string, handler: EventHandler<T>): () => void {
    if (!this.once.has(event)) {
      this.once.set(event, new Set());
    }
    
    this.once.get(event)!.add(handler);
    
    return () => {
      this.once.get(event)?.delete(handler);
    };
  }
  
  // å‘å¸ƒäº‹ä»¶
  emit<T>(event: string, data?: T): void {
    // å¤„ç†æ™®é€šè®¢é˜…
    const handlers = this.events.get(event);
    if (handlers) {
      handlers.forEach(handler => {
        try {
          handler(data);
        } catch (error) {
          console.error(`Event handler error for "${event}":`, error);
        }
      });
    }
    
    // å¤„ç†ä¸€æ¬¡æ€§è®¢é˜…
    const onceHandlers = this.once.get(event);
    if (onceHandlers) {
      onceHandlers.forEach(handler => {
        try {
          handler(data);
        } catch (error) {
          console.error(`Once event handler error for "${event}":`, error);
        }
      });
      this.once.delete(event); // æ‰§è¡Œååˆ é™¤
    }
  }
  
  // æ¸…é™¤æ‰€æœ‰è®¢é˜…
  clear(event?: string): void {
    if (event) {
      this.events.delete(event);
      this.once.delete(event);
    } else {
      this.events.clear();
      this.once.clear();
    }
  }
  
  // è·å–è®¢é˜…æ•°é‡
  getListenerCount(event: string): number {
    const regular = this.events.get(event)?.size || 0;
    const once = this.once.get(event)?.size || 0;
    return regular + once;
  }
}

export const messageBus = new MessageBus();
```

### 2. å…¨å±€çŠ¶æ€ç®¡ç†
```typescript
// stores/globalStore.ts
interface GlobalState {
  user: {
    id: string;
    name: string;
    email: string;
    preferences: UserPreferences;
  } | null;
  
  extension: {
    version: string;
    permissions: string[];
    status: 'active' | 'inactive' | 'error';
  };
  
  ui: {
    theme: 'light' | 'dark';
    sidebarOpen: boolean;
    notifications: Notification[];
  };
  
  data: {
    tabs: chrome.tabs.Tab[];
    bookmarks: chrome.bookmarks.BookmarkTreeNode[];
    history: chrome.history.HistoryItem[];
    lastSync: number;
  };
}

type StateUpdater<T> = T | ((prev: T) => T);

class GlobalStore {
  private state: GlobalState;
  private subscribers = new Set<(state: GlobalState) => void>();
  
  constructor(initialState: GlobalState) {
    this.state = initialState;
  }
  
  // è·å–å½“å‰çŠ¶æ€
  getState(): GlobalState {
    return this.state;
  }
  
  // è®¢é˜…çŠ¶æ€å˜åŒ–
  subscribe(callback: (state: GlobalState) => void): () => void {
    this.subscribers.add(callback);
    
    return () => {
      this.subscribers.delete(callback);
    };
  }
  
  // æ›´æ–°çŠ¶æ€
  setState<K extends keyof GlobalState>(
    key: K,
    updater: StateUpdater<GlobalState[K]>
  ): void {
    const newValue = typeof updater === 'function' 
      ? (updater as Function)(this.state[key])
      : updater;
      
    this.state = {
      ...this.state,
      [key]: newValue
    };
    
    this.notifySubscribers();
  }
  
  // æ·±åº¦æ›´æ–°åµŒå¥—çŠ¶æ€
  updateNested<K extends keyof GlobalState, NK extends keyof GlobalState[K]>(
    key: K,
    nestedKey: NK,
    updater: StateUpdater<GlobalState[K][NK]>
  ): void {
    const currentNested = this.state[key] as any;
    const newValue = typeof updater === 'function'
      ? (updater as Function)(currentNested[nestedKey])
      : updater;
      
    this.setState(key, {
      ...currentNested,
      [nestedKey]: newValue
    } as GlobalState[K]);
  }
  
  private notifySubscribers(): void {
    this.subscribers.forEach(callback => {
      try {
        callback(this.state);
      } catch (error) {
        console.error('Store subscriber error:', error);
      }
    });
  }
}

const initialState: GlobalState = {
  user: null,
  extension: {
    version: chrome.runtime.getManifest().version,
    permissions: [],
    status: 'active'
  },
  ui: {
    theme: 'light',
    sidebarOpen: true,
    notifications: []
  },
  data: {
    tabs: [],
    bookmarks: [],
    history: [],
    lastSync: 0
  }
};

export const globalStore = new GlobalStore(initialState);

// React Hook
export function useGlobalStore<T>(
  selector?: (state: GlobalState) => T
): [T, GlobalStore] {
  const [state, setState] = useState(() => 
    selector ? selector(globalStore.getState()) : globalStore.getState()
  );
  
  useEffect(() => {
    const unsubscribe = globalStore.subscribe((newState) => {
      const newSelectedState = selector ? selector(newState) : newState;
      setState(newSelectedState as any);
    });
    
    return unsubscribe;
  }, [selector]);
  
  return [state, globalStore];
}
```

## æ€»ç»“

é€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œä½ åº”è¯¥æŒæ¡ï¼š

âœ… **Background Script é«˜çº§å¼€å‘**
- æœåŠ¡å·¥ä½œçº¿ç¨‹æ¶æ„è®¾è®¡
- æ¶ˆæ¯è·¯ç”±å’ŒAPIç®¡ç†ç³»ç»Ÿ
- å®šæ—¶ä»»åŠ¡å’Œç”Ÿå‘½å‘¨æœŸç®¡ç†

âœ… **Content Script æœ€ä½³å®è·µ**
- å®‰å…¨çš„é¡µé¢äº¤äº’æœºåˆ¶
- DOMç›‘æ§å’Œå†…å®¹åˆ†æ
- æ€§èƒ½ä¼˜åŒ–å’Œé”™è¯¯å¤„ç†

âœ… **Popup å’Œ Options å¼€å‘**
- å“åº”å¼ç•Œé¢è®¾è®¡
- é«˜æ€§èƒ½ç»„ä»¶å¼€å‘
- è®¾ç½®ç®¡ç†ç³»ç»Ÿ

âœ… **è·¨ç»„ä»¶é€šä¿¡ç³»ç»Ÿ**
- æ¶ˆæ¯æ€»çº¿å®ç°
- å…¨å±€çŠ¶æ€ç®¡ç†
- æ•°æ®åŒæ­¥æœºåˆ¶

ä¸‹ä¸€ç« æˆ‘ä»¬å°†å­¦ä¹ æ‰©å±•çš„æ„å»ºä¼˜åŒ–å’Œéƒ¨ç½²å‘å¸ƒæµç¨‹ã€‚
